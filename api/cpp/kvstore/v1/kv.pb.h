// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kvstore/v1/kv.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_kvstore_2fv1_2fkv_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_kvstore_2fv1_2fkv_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "errors/v1/errors.pb.h"
#include <google/protobuf/timestamp.pb.h>
#include "kvstore/v1/transactions.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_kvstore_2fv1_2fkv_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_kvstore_2fv1_2fkv_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_kvstore_2fv1_2fkv_2eproto;
namespace kvstore {
namespace v1 {
class AccountDescriptor;
struct AccountDescriptorDefaultTypeInternal;
extern AccountDescriptorDefaultTypeInternal _AccountDescriptor_default_instance_;
class BucketDescriptor;
struct BucketDescriptorDefaultTypeInternal;
extern BucketDescriptorDefaultTypeInternal _BucketDescriptor_default_instance_;
class CreateAccountRequest;
struct CreateAccountRequestDefaultTypeInternal;
extern CreateAccountRequestDefaultTypeInternal _CreateAccountRequest_default_instance_;
class CreateAccountResponse;
struct CreateAccountResponseDefaultTypeInternal;
extern CreateAccountResponseDefaultTypeInternal _CreateAccountResponse_default_instance_;
class CreateBucketRequest;
struct CreateBucketRequestDefaultTypeInternal;
extern CreateBucketRequestDefaultTypeInternal _CreateBucketRequest_default_instance_;
class CreateBucketResponse;
struct CreateBucketResponseDefaultTypeInternal;
extern CreateBucketResponseDefaultTypeInternal _CreateBucketResponse_default_instance_;
class DeleteAccountRequest;
struct DeleteAccountRequestDefaultTypeInternal;
extern DeleteAccountRequestDefaultTypeInternal _DeleteAccountRequest_default_instance_;
class DeleteAccountResponse;
struct DeleteAccountResponseDefaultTypeInternal;
extern DeleteAccountResponseDefaultTypeInternal _DeleteAccountResponse_default_instance_;
class DeleteBucketRequest;
struct DeleteBucketRequestDefaultTypeInternal;
extern DeleteBucketRequestDefaultTypeInternal _DeleteBucketRequest_default_instance_;
class DeleteBucketResponse;
struct DeleteBucketResponseDefaultTypeInternal;
extern DeleteBucketResponseDefaultTypeInternal _DeleteBucketResponse_default_instance_;
class DeleteKeyRequest;
struct DeleteKeyRequestDefaultTypeInternal;
extern DeleteKeyRequestDefaultTypeInternal _DeleteKeyRequest_default_instance_;
class DeleteKeyResponse;
struct DeleteKeyResponseDefaultTypeInternal;
extern DeleteKeyResponseDefaultTypeInternal _DeleteKeyResponse_default_instance_;
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class GetAccountDescriptorRequest;
struct GetAccountDescriptorRequestDefaultTypeInternal;
extern GetAccountDescriptorRequestDefaultTypeInternal _GetAccountDescriptorRequest_default_instance_;
class GetAccountDescriptorResponse;
struct GetAccountDescriptorResponseDefaultTypeInternal;
extern GetAccountDescriptorResponseDefaultTypeInternal _GetAccountDescriptorResponse_default_instance_;
class GetBucketDescriptorRequest;
struct GetBucketDescriptorRequestDefaultTypeInternal;
extern GetBucketDescriptorRequestDefaultTypeInternal _GetBucketDescriptorRequest_default_instance_;
class GetBucketDescriptorResponse;
struct GetBucketDescriptorResponseDefaultTypeInternal;
extern GetBucketDescriptorResponseDefaultTypeInternal _GetBucketDescriptorResponse_default_instance_;
class GetKeyRequest;
struct GetKeyRequestDefaultTypeInternal;
extern GetKeyRequestDefaultTypeInternal _GetKeyRequest_default_instance_;
class GetKeyResponse;
struct GetKeyResponseDefaultTypeInternal;
extern GetKeyResponseDefaultTypeInternal _GetKeyResponse_default_instance_;
class KVStoreWrapper;
struct KVStoreWrapperDefaultTypeInternal;
extern KVStoreWrapperDefaultTypeInternal _KVStoreWrapper_default_instance_;
class KeyValue;
struct KeyValueDefaultTypeInternal;
extern KeyValueDefaultTypeInternal _KeyValue_default_instance_;
class KeyValueDescriptor;
struct KeyValueDescriptorDefaultTypeInternal;
extern KeyValueDescriptorDefaultTypeInternal _KeyValueDescriptor_default_instance_;
class ListKeyVersionsRequest;
struct ListKeyVersionsRequestDefaultTypeInternal;
extern ListKeyVersionsRequestDefaultTypeInternal _ListKeyVersionsRequest_default_instance_;
class ListKeyVersionsResponse;
struct ListKeyVersionsResponseDefaultTypeInternal;
extern ListKeyVersionsResponseDefaultTypeInternal _ListKeyVersionsResponse_default_instance_;
class PutKeyRequest;
struct PutKeyRequestDefaultTypeInternal;
extern PutKeyRequestDefaultTypeInternal _PutKeyRequest_default_instance_;
class PutKeyResponse;
struct PutKeyResponseDefaultTypeInternal;
extern PutKeyResponseDefaultTypeInternal _PutKeyResponse_default_instance_;
}  // namespace v1
}  // namespace kvstore
PROTOBUF_NAMESPACE_OPEN
template<> ::kvstore::v1::AccountDescriptor* Arena::CreateMaybeMessage<::kvstore::v1::AccountDescriptor>(Arena*);
template<> ::kvstore::v1::BucketDescriptor* Arena::CreateMaybeMessage<::kvstore::v1::BucketDescriptor>(Arena*);
template<> ::kvstore::v1::CreateAccountRequest* Arena::CreateMaybeMessage<::kvstore::v1::CreateAccountRequest>(Arena*);
template<> ::kvstore::v1::CreateAccountResponse* Arena::CreateMaybeMessage<::kvstore::v1::CreateAccountResponse>(Arena*);
template<> ::kvstore::v1::CreateBucketRequest* Arena::CreateMaybeMessage<::kvstore::v1::CreateBucketRequest>(Arena*);
template<> ::kvstore::v1::CreateBucketResponse* Arena::CreateMaybeMessage<::kvstore::v1::CreateBucketResponse>(Arena*);
template<> ::kvstore::v1::DeleteAccountRequest* Arena::CreateMaybeMessage<::kvstore::v1::DeleteAccountRequest>(Arena*);
template<> ::kvstore::v1::DeleteAccountResponse* Arena::CreateMaybeMessage<::kvstore::v1::DeleteAccountResponse>(Arena*);
template<> ::kvstore::v1::DeleteBucketRequest* Arena::CreateMaybeMessage<::kvstore::v1::DeleteBucketRequest>(Arena*);
template<> ::kvstore::v1::DeleteBucketResponse* Arena::CreateMaybeMessage<::kvstore::v1::DeleteBucketResponse>(Arena*);
template<> ::kvstore::v1::DeleteKeyRequest* Arena::CreateMaybeMessage<::kvstore::v1::DeleteKeyRequest>(Arena*);
template<> ::kvstore::v1::DeleteKeyResponse* Arena::CreateMaybeMessage<::kvstore::v1::DeleteKeyResponse>(Arena*);
template<> ::kvstore::v1::Event* Arena::CreateMaybeMessage<::kvstore::v1::Event>(Arena*);
template<> ::kvstore::v1::GetAccountDescriptorRequest* Arena::CreateMaybeMessage<::kvstore::v1::GetAccountDescriptorRequest>(Arena*);
template<> ::kvstore::v1::GetAccountDescriptorResponse* Arena::CreateMaybeMessage<::kvstore::v1::GetAccountDescriptorResponse>(Arena*);
template<> ::kvstore::v1::GetBucketDescriptorRequest* Arena::CreateMaybeMessage<::kvstore::v1::GetBucketDescriptorRequest>(Arena*);
template<> ::kvstore::v1::GetBucketDescriptorResponse* Arena::CreateMaybeMessage<::kvstore::v1::GetBucketDescriptorResponse>(Arena*);
template<> ::kvstore::v1::GetKeyRequest* Arena::CreateMaybeMessage<::kvstore::v1::GetKeyRequest>(Arena*);
template<> ::kvstore::v1::GetKeyResponse* Arena::CreateMaybeMessage<::kvstore::v1::GetKeyResponse>(Arena*);
template<> ::kvstore::v1::KVStoreWrapper* Arena::CreateMaybeMessage<::kvstore::v1::KVStoreWrapper>(Arena*);
template<> ::kvstore::v1::KeyValue* Arena::CreateMaybeMessage<::kvstore::v1::KeyValue>(Arena*);
template<> ::kvstore::v1::KeyValueDescriptor* Arena::CreateMaybeMessage<::kvstore::v1::KeyValueDescriptor>(Arena*);
template<> ::kvstore::v1::ListKeyVersionsRequest* Arena::CreateMaybeMessage<::kvstore::v1::ListKeyVersionsRequest>(Arena*);
template<> ::kvstore::v1::ListKeyVersionsResponse* Arena::CreateMaybeMessage<::kvstore::v1::ListKeyVersionsResponse>(Arena*);
template<> ::kvstore::v1::PutKeyRequest* Arena::CreateMaybeMessage<::kvstore::v1::PutKeyRequest>(Arena*);
template<> ::kvstore::v1::PutKeyResponse* Arena::CreateMaybeMessage<::kvstore::v1::PutKeyResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace kvstore {
namespace v1 {

enum KVStoreWrapper_RequestType : int {
  KVStoreWrapper_RequestType_REQUEST_TYPE_UNSPECIFIED = 0,
  KVStoreWrapper_RequestType_REQUEST_TYPE_CREATE_ACCOUNT_REQUEST = 1,
  KVStoreWrapper_RequestType_REQUEST_TYPE_CREATE_ACCOUNT_REPLY = 2,
  KVStoreWrapper_RequestType_REQUEST_TYPE_DELETE_ACCOUNT_REQUEST = 3,
  KVStoreWrapper_RequestType_REQUEST_TYPE_DELETE_ACCOUNT_REPLY = 4,
  KVStoreWrapper_RequestType_REQUEST_TYPE_GET_ACCOUNT_DESCRIPTOR_REQUEST = 5,
  KVStoreWrapper_RequestType_REQUEST_TYPE_GET_ACCOUNT_DESCRIPTOR_REPLY = 6,
  KVStoreWrapper_RequestType_REQUEST_TYPE_CREATE_BUCKET_REQUEST = 7,
  KVStoreWrapper_RequestType_REQUEST_TYPE_CREATE_BUCKET_REPLY = 8,
  KVStoreWrapper_RequestType_REQUEST_TYPE_DELETE_BUCKET_REQUEST = 9,
  KVStoreWrapper_RequestType_REQUEST_TYPE_DELETE_BUCKET_REPLY = 10,
  KVStoreWrapper_RequestType_REQUEST_TYPE_GET_KEY_REQUEST = 11,
  KVStoreWrapper_RequestType_REQUEST_TYPE_GET_KEY_REPLY = 12,
  KVStoreWrapper_RequestType_REQUEST_TYPE_PUT_KEY_REQUEST = 13,
  KVStoreWrapper_RequestType_REQUEST_TYPE_PUT_KEY_REPLY = 14,
  KVStoreWrapper_RequestType_REQUEST_TYPE_DELETE_KEY_REQUEST = 15,
  KVStoreWrapper_RequestType_REQUEST_TYPE_DELETE_KEY_REPLY = 16,
  KVStoreWrapper_RequestType_REQUEST_TYPE_GET_BUCKET_DESCRIPTOR_REQUEST = 17,
  KVStoreWrapper_RequestType_REQUEST_TYPE_GET_BUCKET_DESCRIPTOR_REPLY = 18,
  KVStoreWrapper_RequestType_REQUEST_TYPE_RECOVERABLE_ERROR = 19,
  KVStoreWrapper_RequestType_KVStoreWrapper_RequestType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  KVStoreWrapper_RequestType_KVStoreWrapper_RequestType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool KVStoreWrapper_RequestType_IsValid(int value);
constexpr KVStoreWrapper_RequestType KVStoreWrapper_RequestType_RequestType_MIN = KVStoreWrapper_RequestType_REQUEST_TYPE_UNSPECIFIED;
constexpr KVStoreWrapper_RequestType KVStoreWrapper_RequestType_RequestType_MAX = KVStoreWrapper_RequestType_REQUEST_TYPE_RECOVERABLE_ERROR;
constexpr int KVStoreWrapper_RequestType_RequestType_ARRAYSIZE = KVStoreWrapper_RequestType_RequestType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KVStoreWrapper_RequestType_descriptor();
template<typename T>
inline const std::string& KVStoreWrapper_RequestType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KVStoreWrapper_RequestType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KVStoreWrapper_RequestType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KVStoreWrapper_RequestType_descriptor(), enum_t_value);
}
inline bool KVStoreWrapper_RequestType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KVStoreWrapper_RequestType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KVStoreWrapper_RequestType>(
    KVStoreWrapper_RequestType_descriptor(), name, value);
}
enum KeyOperationType : int {
  KEY_OPERATION_TYPE_UNSPECIFIED = 0,
  KEY_OPERATION_TYPE_GET = 1,
  KEY_OPERATION_TYPE_PUT = 2,
  KEY_OPERATION_TYPE_DELETE = 3,
  KeyOperationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  KeyOperationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool KeyOperationType_IsValid(int value);
constexpr KeyOperationType KeyOperationType_MIN = KEY_OPERATION_TYPE_UNSPECIFIED;
constexpr KeyOperationType KeyOperationType_MAX = KEY_OPERATION_TYPE_DELETE;
constexpr int KeyOperationType_ARRAYSIZE = KeyOperationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KeyOperationType_descriptor();
template<typename T>
inline const std::string& KeyOperationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KeyOperationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KeyOperationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KeyOperationType_descriptor(), enum_t_value);
}
inline bool KeyOperationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KeyOperationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KeyOperationType>(
    KeyOperationType_descriptor(), name, value);
}
// ===================================================================

class KVStoreWrapper final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.KVStoreWrapper) */ {
 public:
  inline KVStoreWrapper() : KVStoreWrapper(nullptr) {}
  ~KVStoreWrapper() override;
  explicit PROTOBUF_CONSTEXPR KVStoreWrapper(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KVStoreWrapper(const KVStoreWrapper& from);
  KVStoreWrapper(KVStoreWrapper&& from) noexcept
    : KVStoreWrapper() {
    *this = ::std::move(from);
  }

  inline KVStoreWrapper& operator=(const KVStoreWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline KVStoreWrapper& operator=(KVStoreWrapper&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KVStoreWrapper& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kCreateAccountRequest = 4,
    kCreateAccountReply = 5,
    kDeleteAccountRequest = 6,
    kDeleteAccountReply = 7,
    kGetAccountDescriptorRequest = 8,
    kGetAccountDescriptorReply = 9,
    kCreateBucketRequest = 10,
    kCreateBucketReply = 11,
    kDeleteBucketRequest = 12,
    kDeleteBucketReply = 13,
    kGetKeyRequest = 14,
    kGetKeyReply = 15,
    kPutKeyRequest = 16,
    kPutKeyReply = 17,
    kDeleteKeyRequest = 18,
    kDeleteKeyReply = 19,
    kGetBucketDescriptorRequest = 20,
    kGetBucketDescriptorReply = 21,
    kError = 22,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const KVStoreWrapper* internal_default_instance() {
    return reinterpret_cast<const KVStoreWrapper*>(
               &_KVStoreWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(KVStoreWrapper& a, KVStoreWrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(KVStoreWrapper* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KVStoreWrapper* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KVStoreWrapper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KVStoreWrapper>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KVStoreWrapper& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KVStoreWrapper& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KVStoreWrapper* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.KVStoreWrapper";
  }
  protected:
  explicit KVStoreWrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef KVStoreWrapper_RequestType RequestType;
  static constexpr RequestType REQUEST_TYPE_UNSPECIFIED =
    KVStoreWrapper_RequestType_REQUEST_TYPE_UNSPECIFIED;
  static constexpr RequestType REQUEST_TYPE_CREATE_ACCOUNT_REQUEST =
    KVStoreWrapper_RequestType_REQUEST_TYPE_CREATE_ACCOUNT_REQUEST;
  static constexpr RequestType REQUEST_TYPE_CREATE_ACCOUNT_REPLY =
    KVStoreWrapper_RequestType_REQUEST_TYPE_CREATE_ACCOUNT_REPLY;
  static constexpr RequestType REQUEST_TYPE_DELETE_ACCOUNT_REQUEST =
    KVStoreWrapper_RequestType_REQUEST_TYPE_DELETE_ACCOUNT_REQUEST;
  static constexpr RequestType REQUEST_TYPE_DELETE_ACCOUNT_REPLY =
    KVStoreWrapper_RequestType_REQUEST_TYPE_DELETE_ACCOUNT_REPLY;
  static constexpr RequestType REQUEST_TYPE_GET_ACCOUNT_DESCRIPTOR_REQUEST =
    KVStoreWrapper_RequestType_REQUEST_TYPE_GET_ACCOUNT_DESCRIPTOR_REQUEST;
  static constexpr RequestType REQUEST_TYPE_GET_ACCOUNT_DESCRIPTOR_REPLY =
    KVStoreWrapper_RequestType_REQUEST_TYPE_GET_ACCOUNT_DESCRIPTOR_REPLY;
  static constexpr RequestType REQUEST_TYPE_CREATE_BUCKET_REQUEST =
    KVStoreWrapper_RequestType_REQUEST_TYPE_CREATE_BUCKET_REQUEST;
  static constexpr RequestType REQUEST_TYPE_CREATE_BUCKET_REPLY =
    KVStoreWrapper_RequestType_REQUEST_TYPE_CREATE_BUCKET_REPLY;
  static constexpr RequestType REQUEST_TYPE_DELETE_BUCKET_REQUEST =
    KVStoreWrapper_RequestType_REQUEST_TYPE_DELETE_BUCKET_REQUEST;
  static constexpr RequestType REQUEST_TYPE_DELETE_BUCKET_REPLY =
    KVStoreWrapper_RequestType_REQUEST_TYPE_DELETE_BUCKET_REPLY;
  static constexpr RequestType REQUEST_TYPE_GET_KEY_REQUEST =
    KVStoreWrapper_RequestType_REQUEST_TYPE_GET_KEY_REQUEST;
  static constexpr RequestType REQUEST_TYPE_GET_KEY_REPLY =
    KVStoreWrapper_RequestType_REQUEST_TYPE_GET_KEY_REPLY;
  static constexpr RequestType REQUEST_TYPE_PUT_KEY_REQUEST =
    KVStoreWrapper_RequestType_REQUEST_TYPE_PUT_KEY_REQUEST;
  static constexpr RequestType REQUEST_TYPE_PUT_KEY_REPLY =
    KVStoreWrapper_RequestType_REQUEST_TYPE_PUT_KEY_REPLY;
  static constexpr RequestType REQUEST_TYPE_DELETE_KEY_REQUEST =
    KVStoreWrapper_RequestType_REQUEST_TYPE_DELETE_KEY_REQUEST;
  static constexpr RequestType REQUEST_TYPE_DELETE_KEY_REPLY =
    KVStoreWrapper_RequestType_REQUEST_TYPE_DELETE_KEY_REPLY;
  static constexpr RequestType REQUEST_TYPE_GET_BUCKET_DESCRIPTOR_REQUEST =
    KVStoreWrapper_RequestType_REQUEST_TYPE_GET_BUCKET_DESCRIPTOR_REQUEST;
  static constexpr RequestType REQUEST_TYPE_GET_BUCKET_DESCRIPTOR_REPLY =
    KVStoreWrapper_RequestType_REQUEST_TYPE_GET_BUCKET_DESCRIPTOR_REPLY;
  static constexpr RequestType REQUEST_TYPE_RECOVERABLE_ERROR =
    KVStoreWrapper_RequestType_REQUEST_TYPE_RECOVERABLE_ERROR;
  static inline bool RequestType_IsValid(int value) {
    return KVStoreWrapper_RequestType_IsValid(value);
  }
  static constexpr RequestType RequestType_MIN =
    KVStoreWrapper_RequestType_RequestType_MIN;
  static constexpr RequestType RequestType_MAX =
    KVStoreWrapper_RequestType_RequestType_MAX;
  static constexpr int RequestType_ARRAYSIZE =
    KVStoreWrapper_RequestType_RequestType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RequestType_descriptor() {
    return KVStoreWrapper_RequestType_descriptor();
  }
  template<typename T>
  static inline const std::string& RequestType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RequestType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RequestType_Name.");
    return KVStoreWrapper_RequestType_Name(enum_t_value);
  }
  static inline bool RequestType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RequestType* value) {
    return KVStoreWrapper_RequestType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBucketFieldNumber = 2,
    kAccountFieldNumber = 1,
    kTypFieldNumber = 3,
    kCreateAccountRequestFieldNumber = 4,
    kCreateAccountReplyFieldNumber = 5,
    kDeleteAccountRequestFieldNumber = 6,
    kDeleteAccountReplyFieldNumber = 7,
    kGetAccountDescriptorRequestFieldNumber = 8,
    kGetAccountDescriptorReplyFieldNumber = 9,
    kCreateBucketRequestFieldNumber = 10,
    kCreateBucketReplyFieldNumber = 11,
    kDeleteBucketRequestFieldNumber = 12,
    kDeleteBucketReplyFieldNumber = 13,
    kGetKeyRequestFieldNumber = 14,
    kGetKeyReplyFieldNumber = 15,
    kPutKeyRequestFieldNumber = 16,
    kPutKeyReplyFieldNumber = 17,
    kDeleteKeyRequestFieldNumber = 18,
    kDeleteKeyReplyFieldNumber = 19,
    kGetBucketDescriptorRequestFieldNumber = 20,
    kGetBucketDescriptorReplyFieldNumber = 21,
    kErrorFieldNumber = 22,
  };
  // string bucket = 2 [json_name = "bucket"];
  void clear_bucket();
  const std::string& bucket() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bucket(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bucket();
  PROTOBUF_NODISCARD std::string* release_bucket();
  void set_allocated_bucket(std::string* bucket);
  private:
  const std::string& _internal_bucket() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bucket(const std::string& value);
  std::string* _internal_mutable_bucket();
  public:

  // uint64 account = 1 [json_name = "account"];
  void clear_account();
  uint64_t account() const;
  void set_account(uint64_t value);
  private:
  uint64_t _internal_account() const;
  void _internal_set_account(uint64_t value);
  public:

  // .kvstore.v1.KVStoreWrapper.RequestType typ = 3 [json_name = "typ"];
  void clear_typ();
  ::kvstore::v1::KVStoreWrapper_RequestType typ() const;
  void set_typ(::kvstore::v1::KVStoreWrapper_RequestType value);
  private:
  ::kvstore::v1::KVStoreWrapper_RequestType _internal_typ() const;
  void _internal_set_typ(::kvstore::v1::KVStoreWrapper_RequestType value);
  public:

  // .kvstore.v1.CreateAccountRequest create_account_request = 4 [json_name = "createAccountRequest"];
  bool has_create_account_request() const;
  private:
  bool _internal_has_create_account_request() const;
  public:
  void clear_create_account_request();
  const ::kvstore::v1::CreateAccountRequest& create_account_request() const;
  PROTOBUF_NODISCARD ::kvstore::v1::CreateAccountRequest* release_create_account_request();
  ::kvstore::v1::CreateAccountRequest* mutable_create_account_request();
  void set_allocated_create_account_request(::kvstore::v1::CreateAccountRequest* create_account_request);
  private:
  const ::kvstore::v1::CreateAccountRequest& _internal_create_account_request() const;
  ::kvstore::v1::CreateAccountRequest* _internal_mutable_create_account_request();
  public:
  void unsafe_arena_set_allocated_create_account_request(
      ::kvstore::v1::CreateAccountRequest* create_account_request);
  ::kvstore::v1::CreateAccountRequest* unsafe_arena_release_create_account_request();

  // .kvstore.v1.CreateAccountResponse create_account_reply = 5 [json_name = "createAccountReply"];
  bool has_create_account_reply() const;
  private:
  bool _internal_has_create_account_reply() const;
  public:
  void clear_create_account_reply();
  const ::kvstore::v1::CreateAccountResponse& create_account_reply() const;
  PROTOBUF_NODISCARD ::kvstore::v1::CreateAccountResponse* release_create_account_reply();
  ::kvstore::v1::CreateAccountResponse* mutable_create_account_reply();
  void set_allocated_create_account_reply(::kvstore::v1::CreateAccountResponse* create_account_reply);
  private:
  const ::kvstore::v1::CreateAccountResponse& _internal_create_account_reply() const;
  ::kvstore::v1::CreateAccountResponse* _internal_mutable_create_account_reply();
  public:
  void unsafe_arena_set_allocated_create_account_reply(
      ::kvstore::v1::CreateAccountResponse* create_account_reply);
  ::kvstore::v1::CreateAccountResponse* unsafe_arena_release_create_account_reply();

  // .kvstore.v1.DeleteAccountRequest delete_account_request = 6 [json_name = "deleteAccountRequest"];
  bool has_delete_account_request() const;
  private:
  bool _internal_has_delete_account_request() const;
  public:
  void clear_delete_account_request();
  const ::kvstore::v1::DeleteAccountRequest& delete_account_request() const;
  PROTOBUF_NODISCARD ::kvstore::v1::DeleteAccountRequest* release_delete_account_request();
  ::kvstore::v1::DeleteAccountRequest* mutable_delete_account_request();
  void set_allocated_delete_account_request(::kvstore::v1::DeleteAccountRequest* delete_account_request);
  private:
  const ::kvstore::v1::DeleteAccountRequest& _internal_delete_account_request() const;
  ::kvstore::v1::DeleteAccountRequest* _internal_mutable_delete_account_request();
  public:
  void unsafe_arena_set_allocated_delete_account_request(
      ::kvstore::v1::DeleteAccountRequest* delete_account_request);
  ::kvstore::v1::DeleteAccountRequest* unsafe_arena_release_delete_account_request();

  // .kvstore.v1.DeleteAccountResponse delete_account_reply = 7 [json_name = "deleteAccountReply"];
  bool has_delete_account_reply() const;
  private:
  bool _internal_has_delete_account_reply() const;
  public:
  void clear_delete_account_reply();
  const ::kvstore::v1::DeleteAccountResponse& delete_account_reply() const;
  PROTOBUF_NODISCARD ::kvstore::v1::DeleteAccountResponse* release_delete_account_reply();
  ::kvstore::v1::DeleteAccountResponse* mutable_delete_account_reply();
  void set_allocated_delete_account_reply(::kvstore::v1::DeleteAccountResponse* delete_account_reply);
  private:
  const ::kvstore::v1::DeleteAccountResponse& _internal_delete_account_reply() const;
  ::kvstore::v1::DeleteAccountResponse* _internal_mutable_delete_account_reply();
  public:
  void unsafe_arena_set_allocated_delete_account_reply(
      ::kvstore::v1::DeleteAccountResponse* delete_account_reply);
  ::kvstore::v1::DeleteAccountResponse* unsafe_arena_release_delete_account_reply();

  // .kvstore.v1.GetAccountDescriptorRequest get_account_descriptor_request = 8 [json_name = "getAccountDescriptorRequest"];
  bool has_get_account_descriptor_request() const;
  private:
  bool _internal_has_get_account_descriptor_request() const;
  public:
  void clear_get_account_descriptor_request();
  const ::kvstore::v1::GetAccountDescriptorRequest& get_account_descriptor_request() const;
  PROTOBUF_NODISCARD ::kvstore::v1::GetAccountDescriptorRequest* release_get_account_descriptor_request();
  ::kvstore::v1::GetAccountDescriptorRequest* mutable_get_account_descriptor_request();
  void set_allocated_get_account_descriptor_request(::kvstore::v1::GetAccountDescriptorRequest* get_account_descriptor_request);
  private:
  const ::kvstore::v1::GetAccountDescriptorRequest& _internal_get_account_descriptor_request() const;
  ::kvstore::v1::GetAccountDescriptorRequest* _internal_mutable_get_account_descriptor_request();
  public:
  void unsafe_arena_set_allocated_get_account_descriptor_request(
      ::kvstore::v1::GetAccountDescriptorRequest* get_account_descriptor_request);
  ::kvstore::v1::GetAccountDescriptorRequest* unsafe_arena_release_get_account_descriptor_request();

  // .kvstore.v1.GetAccountDescriptorResponse get_account_descriptor_reply = 9 [json_name = "getAccountDescriptorReply"];
  bool has_get_account_descriptor_reply() const;
  private:
  bool _internal_has_get_account_descriptor_reply() const;
  public:
  void clear_get_account_descriptor_reply();
  const ::kvstore::v1::GetAccountDescriptorResponse& get_account_descriptor_reply() const;
  PROTOBUF_NODISCARD ::kvstore::v1::GetAccountDescriptorResponse* release_get_account_descriptor_reply();
  ::kvstore::v1::GetAccountDescriptorResponse* mutable_get_account_descriptor_reply();
  void set_allocated_get_account_descriptor_reply(::kvstore::v1::GetAccountDescriptorResponse* get_account_descriptor_reply);
  private:
  const ::kvstore::v1::GetAccountDescriptorResponse& _internal_get_account_descriptor_reply() const;
  ::kvstore::v1::GetAccountDescriptorResponse* _internal_mutable_get_account_descriptor_reply();
  public:
  void unsafe_arena_set_allocated_get_account_descriptor_reply(
      ::kvstore::v1::GetAccountDescriptorResponse* get_account_descriptor_reply);
  ::kvstore::v1::GetAccountDescriptorResponse* unsafe_arena_release_get_account_descriptor_reply();

  // .kvstore.v1.CreateBucketRequest create_bucket_request = 10 [json_name = "createBucketRequest"];
  bool has_create_bucket_request() const;
  private:
  bool _internal_has_create_bucket_request() const;
  public:
  void clear_create_bucket_request();
  const ::kvstore::v1::CreateBucketRequest& create_bucket_request() const;
  PROTOBUF_NODISCARD ::kvstore::v1::CreateBucketRequest* release_create_bucket_request();
  ::kvstore::v1::CreateBucketRequest* mutable_create_bucket_request();
  void set_allocated_create_bucket_request(::kvstore::v1::CreateBucketRequest* create_bucket_request);
  private:
  const ::kvstore::v1::CreateBucketRequest& _internal_create_bucket_request() const;
  ::kvstore::v1::CreateBucketRequest* _internal_mutable_create_bucket_request();
  public:
  void unsafe_arena_set_allocated_create_bucket_request(
      ::kvstore::v1::CreateBucketRequest* create_bucket_request);
  ::kvstore::v1::CreateBucketRequest* unsafe_arena_release_create_bucket_request();

  // .kvstore.v1.CreateBucketResponse create_bucket_reply = 11 [json_name = "createBucketReply"];
  bool has_create_bucket_reply() const;
  private:
  bool _internal_has_create_bucket_reply() const;
  public:
  void clear_create_bucket_reply();
  const ::kvstore::v1::CreateBucketResponse& create_bucket_reply() const;
  PROTOBUF_NODISCARD ::kvstore::v1::CreateBucketResponse* release_create_bucket_reply();
  ::kvstore::v1::CreateBucketResponse* mutable_create_bucket_reply();
  void set_allocated_create_bucket_reply(::kvstore::v1::CreateBucketResponse* create_bucket_reply);
  private:
  const ::kvstore::v1::CreateBucketResponse& _internal_create_bucket_reply() const;
  ::kvstore::v1::CreateBucketResponse* _internal_mutable_create_bucket_reply();
  public:
  void unsafe_arena_set_allocated_create_bucket_reply(
      ::kvstore::v1::CreateBucketResponse* create_bucket_reply);
  ::kvstore::v1::CreateBucketResponse* unsafe_arena_release_create_bucket_reply();

  // .kvstore.v1.DeleteBucketRequest delete_bucket_request = 12 [json_name = "deleteBucketRequest"];
  bool has_delete_bucket_request() const;
  private:
  bool _internal_has_delete_bucket_request() const;
  public:
  void clear_delete_bucket_request();
  const ::kvstore::v1::DeleteBucketRequest& delete_bucket_request() const;
  PROTOBUF_NODISCARD ::kvstore::v1::DeleteBucketRequest* release_delete_bucket_request();
  ::kvstore::v1::DeleteBucketRequest* mutable_delete_bucket_request();
  void set_allocated_delete_bucket_request(::kvstore::v1::DeleteBucketRequest* delete_bucket_request);
  private:
  const ::kvstore::v1::DeleteBucketRequest& _internal_delete_bucket_request() const;
  ::kvstore::v1::DeleteBucketRequest* _internal_mutable_delete_bucket_request();
  public:
  void unsafe_arena_set_allocated_delete_bucket_request(
      ::kvstore::v1::DeleteBucketRequest* delete_bucket_request);
  ::kvstore::v1::DeleteBucketRequest* unsafe_arena_release_delete_bucket_request();

  // .kvstore.v1.DeleteBucketResponse delete_bucket_reply = 13 [json_name = "deleteBucketReply"];
  bool has_delete_bucket_reply() const;
  private:
  bool _internal_has_delete_bucket_reply() const;
  public:
  void clear_delete_bucket_reply();
  const ::kvstore::v1::DeleteBucketResponse& delete_bucket_reply() const;
  PROTOBUF_NODISCARD ::kvstore::v1::DeleteBucketResponse* release_delete_bucket_reply();
  ::kvstore::v1::DeleteBucketResponse* mutable_delete_bucket_reply();
  void set_allocated_delete_bucket_reply(::kvstore::v1::DeleteBucketResponse* delete_bucket_reply);
  private:
  const ::kvstore::v1::DeleteBucketResponse& _internal_delete_bucket_reply() const;
  ::kvstore::v1::DeleteBucketResponse* _internal_mutable_delete_bucket_reply();
  public:
  void unsafe_arena_set_allocated_delete_bucket_reply(
      ::kvstore::v1::DeleteBucketResponse* delete_bucket_reply);
  ::kvstore::v1::DeleteBucketResponse* unsafe_arena_release_delete_bucket_reply();

  // .kvstore.v1.GetKeyRequest get_key_request = 14 [json_name = "getKeyRequest"];
  bool has_get_key_request() const;
  private:
  bool _internal_has_get_key_request() const;
  public:
  void clear_get_key_request();
  const ::kvstore::v1::GetKeyRequest& get_key_request() const;
  PROTOBUF_NODISCARD ::kvstore::v1::GetKeyRequest* release_get_key_request();
  ::kvstore::v1::GetKeyRequest* mutable_get_key_request();
  void set_allocated_get_key_request(::kvstore::v1::GetKeyRequest* get_key_request);
  private:
  const ::kvstore::v1::GetKeyRequest& _internal_get_key_request() const;
  ::kvstore::v1::GetKeyRequest* _internal_mutable_get_key_request();
  public:
  void unsafe_arena_set_allocated_get_key_request(
      ::kvstore::v1::GetKeyRequest* get_key_request);
  ::kvstore::v1::GetKeyRequest* unsafe_arena_release_get_key_request();

  // .kvstore.v1.GetKeyResponse get_key_reply = 15 [json_name = "getKeyReply"];
  bool has_get_key_reply() const;
  private:
  bool _internal_has_get_key_reply() const;
  public:
  void clear_get_key_reply();
  const ::kvstore::v1::GetKeyResponse& get_key_reply() const;
  PROTOBUF_NODISCARD ::kvstore::v1::GetKeyResponse* release_get_key_reply();
  ::kvstore::v1::GetKeyResponse* mutable_get_key_reply();
  void set_allocated_get_key_reply(::kvstore::v1::GetKeyResponse* get_key_reply);
  private:
  const ::kvstore::v1::GetKeyResponse& _internal_get_key_reply() const;
  ::kvstore::v1::GetKeyResponse* _internal_mutable_get_key_reply();
  public:
  void unsafe_arena_set_allocated_get_key_reply(
      ::kvstore::v1::GetKeyResponse* get_key_reply);
  ::kvstore::v1::GetKeyResponse* unsafe_arena_release_get_key_reply();

  // .kvstore.v1.PutKeyRequest put_key_request = 16 [json_name = "putKeyRequest"];
  bool has_put_key_request() const;
  private:
  bool _internal_has_put_key_request() const;
  public:
  void clear_put_key_request();
  const ::kvstore::v1::PutKeyRequest& put_key_request() const;
  PROTOBUF_NODISCARD ::kvstore::v1::PutKeyRequest* release_put_key_request();
  ::kvstore::v1::PutKeyRequest* mutable_put_key_request();
  void set_allocated_put_key_request(::kvstore::v1::PutKeyRequest* put_key_request);
  private:
  const ::kvstore::v1::PutKeyRequest& _internal_put_key_request() const;
  ::kvstore::v1::PutKeyRequest* _internal_mutable_put_key_request();
  public:
  void unsafe_arena_set_allocated_put_key_request(
      ::kvstore::v1::PutKeyRequest* put_key_request);
  ::kvstore::v1::PutKeyRequest* unsafe_arena_release_put_key_request();

  // .kvstore.v1.PutKeyResponse put_key_reply = 17 [json_name = "putKeyReply"];
  bool has_put_key_reply() const;
  private:
  bool _internal_has_put_key_reply() const;
  public:
  void clear_put_key_reply();
  const ::kvstore::v1::PutKeyResponse& put_key_reply() const;
  PROTOBUF_NODISCARD ::kvstore::v1::PutKeyResponse* release_put_key_reply();
  ::kvstore::v1::PutKeyResponse* mutable_put_key_reply();
  void set_allocated_put_key_reply(::kvstore::v1::PutKeyResponse* put_key_reply);
  private:
  const ::kvstore::v1::PutKeyResponse& _internal_put_key_reply() const;
  ::kvstore::v1::PutKeyResponse* _internal_mutable_put_key_reply();
  public:
  void unsafe_arena_set_allocated_put_key_reply(
      ::kvstore::v1::PutKeyResponse* put_key_reply);
  ::kvstore::v1::PutKeyResponse* unsafe_arena_release_put_key_reply();

  // .kvstore.v1.DeleteKeyRequest delete_key_request = 18 [json_name = "deleteKeyRequest"];
  bool has_delete_key_request() const;
  private:
  bool _internal_has_delete_key_request() const;
  public:
  void clear_delete_key_request();
  const ::kvstore::v1::DeleteKeyRequest& delete_key_request() const;
  PROTOBUF_NODISCARD ::kvstore::v1::DeleteKeyRequest* release_delete_key_request();
  ::kvstore::v1::DeleteKeyRequest* mutable_delete_key_request();
  void set_allocated_delete_key_request(::kvstore::v1::DeleteKeyRequest* delete_key_request);
  private:
  const ::kvstore::v1::DeleteKeyRequest& _internal_delete_key_request() const;
  ::kvstore::v1::DeleteKeyRequest* _internal_mutable_delete_key_request();
  public:
  void unsafe_arena_set_allocated_delete_key_request(
      ::kvstore::v1::DeleteKeyRequest* delete_key_request);
  ::kvstore::v1::DeleteKeyRequest* unsafe_arena_release_delete_key_request();

  // .kvstore.v1.DeleteKeyResponse delete_key_reply = 19 [json_name = "deleteKeyReply"];
  bool has_delete_key_reply() const;
  private:
  bool _internal_has_delete_key_reply() const;
  public:
  void clear_delete_key_reply();
  const ::kvstore::v1::DeleteKeyResponse& delete_key_reply() const;
  PROTOBUF_NODISCARD ::kvstore::v1::DeleteKeyResponse* release_delete_key_reply();
  ::kvstore::v1::DeleteKeyResponse* mutable_delete_key_reply();
  void set_allocated_delete_key_reply(::kvstore::v1::DeleteKeyResponse* delete_key_reply);
  private:
  const ::kvstore::v1::DeleteKeyResponse& _internal_delete_key_reply() const;
  ::kvstore::v1::DeleteKeyResponse* _internal_mutable_delete_key_reply();
  public:
  void unsafe_arena_set_allocated_delete_key_reply(
      ::kvstore::v1::DeleteKeyResponse* delete_key_reply);
  ::kvstore::v1::DeleteKeyResponse* unsafe_arena_release_delete_key_reply();

  // .kvstore.v1.GetBucketDescriptorRequest get_bucket_descriptor_request = 20 [json_name = "getBucketDescriptorRequest"];
  bool has_get_bucket_descriptor_request() const;
  private:
  bool _internal_has_get_bucket_descriptor_request() const;
  public:
  void clear_get_bucket_descriptor_request();
  const ::kvstore::v1::GetBucketDescriptorRequest& get_bucket_descriptor_request() const;
  PROTOBUF_NODISCARD ::kvstore::v1::GetBucketDescriptorRequest* release_get_bucket_descriptor_request();
  ::kvstore::v1::GetBucketDescriptorRequest* mutable_get_bucket_descriptor_request();
  void set_allocated_get_bucket_descriptor_request(::kvstore::v1::GetBucketDescriptorRequest* get_bucket_descriptor_request);
  private:
  const ::kvstore::v1::GetBucketDescriptorRequest& _internal_get_bucket_descriptor_request() const;
  ::kvstore::v1::GetBucketDescriptorRequest* _internal_mutable_get_bucket_descriptor_request();
  public:
  void unsafe_arena_set_allocated_get_bucket_descriptor_request(
      ::kvstore::v1::GetBucketDescriptorRequest* get_bucket_descriptor_request);
  ::kvstore::v1::GetBucketDescriptorRequest* unsafe_arena_release_get_bucket_descriptor_request();

  // .kvstore.v1.GetBucketDescriptorResponse get_bucket_descriptor_reply = 21 [json_name = "getBucketDescriptorReply"];
  bool has_get_bucket_descriptor_reply() const;
  private:
  bool _internal_has_get_bucket_descriptor_reply() const;
  public:
  void clear_get_bucket_descriptor_reply();
  const ::kvstore::v1::GetBucketDescriptorResponse& get_bucket_descriptor_reply() const;
  PROTOBUF_NODISCARD ::kvstore::v1::GetBucketDescriptorResponse* release_get_bucket_descriptor_reply();
  ::kvstore::v1::GetBucketDescriptorResponse* mutable_get_bucket_descriptor_reply();
  void set_allocated_get_bucket_descriptor_reply(::kvstore::v1::GetBucketDescriptorResponse* get_bucket_descriptor_reply);
  private:
  const ::kvstore::v1::GetBucketDescriptorResponse& _internal_get_bucket_descriptor_reply() const;
  ::kvstore::v1::GetBucketDescriptorResponse* _internal_mutable_get_bucket_descriptor_reply();
  public:
  void unsafe_arena_set_allocated_get_bucket_descriptor_reply(
      ::kvstore::v1::GetBucketDescriptorResponse* get_bucket_descriptor_reply);
  ::kvstore::v1::GetBucketDescriptorResponse* unsafe_arena_release_get_bucket_descriptor_reply();

  // .errors.v1.Error error = 22 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::errors::v1::Error& error() const;
  PROTOBUF_NODISCARD ::errors::v1::Error* release_error();
  ::errors::v1::Error* mutable_error();
  void set_allocated_error(::errors::v1::Error* error);
  private:
  const ::errors::v1::Error& _internal_error() const;
  ::errors::v1::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::errors::v1::Error* error);
  ::errors::v1::Error* unsafe_arena_release_error();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:kvstore.v1.KVStoreWrapper)
 private:
  class _Internal;
  void set_has_create_account_request();
  void set_has_create_account_reply();
  void set_has_delete_account_request();
  void set_has_delete_account_reply();
  void set_has_get_account_descriptor_request();
  void set_has_get_account_descriptor_reply();
  void set_has_create_bucket_request();
  void set_has_create_bucket_reply();
  void set_has_delete_bucket_request();
  void set_has_delete_bucket_reply();
  void set_has_get_key_request();
  void set_has_get_key_reply();
  void set_has_put_key_request();
  void set_has_put_key_reply();
  void set_has_delete_key_request();
  void set_has_delete_key_reply();
  void set_has_get_bucket_descriptor_request();
  void set_has_get_bucket_descriptor_reply();
  void set_has_error();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bucket_;
  uint64_t account_;
  int typ_;
  union PayloadUnion {
    constexpr PayloadUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::kvstore::v1::CreateAccountRequest* create_account_request_;
    ::kvstore::v1::CreateAccountResponse* create_account_reply_;
    ::kvstore::v1::DeleteAccountRequest* delete_account_request_;
    ::kvstore::v1::DeleteAccountResponse* delete_account_reply_;
    ::kvstore::v1::GetAccountDescriptorRequest* get_account_descriptor_request_;
    ::kvstore::v1::GetAccountDescriptorResponse* get_account_descriptor_reply_;
    ::kvstore::v1::CreateBucketRequest* create_bucket_request_;
    ::kvstore::v1::CreateBucketResponse* create_bucket_reply_;
    ::kvstore::v1::DeleteBucketRequest* delete_bucket_request_;
    ::kvstore::v1::DeleteBucketResponse* delete_bucket_reply_;
    ::kvstore::v1::GetKeyRequest* get_key_request_;
    ::kvstore::v1::GetKeyResponse* get_key_reply_;
    ::kvstore::v1::PutKeyRequest* put_key_request_;
    ::kvstore::v1::PutKeyResponse* put_key_reply_;
    ::kvstore::v1::DeleteKeyRequest* delete_key_request_;
    ::kvstore::v1::DeleteKeyResponse* delete_key_reply_;
    ::kvstore::v1::GetBucketDescriptorRequest* get_bucket_descriptor_request_;
    ::kvstore::v1::GetBucketDescriptorResponse* get_bucket_descriptor_reply_;
    ::errors::v1::Error* error_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class CreateAccountRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.CreateAccountRequest) */ {
 public:
  inline CreateAccountRequest() : CreateAccountRequest(nullptr) {}
  ~CreateAccountRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateAccountRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateAccountRequest(const CreateAccountRequest& from);
  CreateAccountRequest(CreateAccountRequest&& from) noexcept
    : CreateAccountRequest() {
    *this = ::std::move(from);
  }

  inline CreateAccountRequest& operator=(const CreateAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAccountRequest& operator=(CreateAccountRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAccountRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateAccountRequest* internal_default_instance() {
    return reinterpret_cast<const CreateAccountRequest*>(
               &_CreateAccountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreateAccountRequest& a, CreateAccountRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateAccountRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAccountRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateAccountRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateAccountRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateAccountRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateAccountRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAccountRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.CreateAccountRequest";
  }
  protected:
  explicit CreateAccountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerFieldNumber = 2,
    kTransactionFieldNumber = 3,
    kAccountIdFieldNumber = 1,
  };
  // string owner = 2 [json_name = "owner"];
  void clear_owner();
  const std::string& owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* owner);
  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(const std::string& value);
  std::string* _internal_mutable_owner();
  public:

  // .kvstore.v1.Transaction transaction = 3 [json_name = "transaction"];
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::kvstore::v1::Transaction& transaction() const;
  PROTOBUF_NODISCARD ::kvstore::v1::Transaction* release_transaction();
  ::kvstore::v1::Transaction* mutable_transaction();
  void set_allocated_transaction(::kvstore::v1::Transaction* transaction);
  private:
  const ::kvstore::v1::Transaction& _internal_transaction() const;
  ::kvstore::v1::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::kvstore::v1::Transaction* transaction);
  ::kvstore::v1::Transaction* unsafe_arena_release_transaction();

  // uint64 account_id = 1 [json_name = "accountId"];
  void clear_account_id();
  uint64_t account_id() const;
  void set_account_id(uint64_t value);
  private:
  uint64_t _internal_account_id() const;
  void _internal_set_account_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:kvstore.v1.CreateAccountRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
  ::kvstore::v1::Transaction* transaction_;
  uint64_t account_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class CreateAccountResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.CreateAccountResponse) */ {
 public:
  inline CreateAccountResponse() : CreateAccountResponse(nullptr) {}
  ~CreateAccountResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateAccountResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateAccountResponse(const CreateAccountResponse& from);
  CreateAccountResponse(CreateAccountResponse&& from) noexcept
    : CreateAccountResponse() {
    *this = ::std::move(from);
  }

  inline CreateAccountResponse& operator=(const CreateAccountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAccountResponse& operator=(CreateAccountResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAccountResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateAccountResponse* internal_default_instance() {
    return reinterpret_cast<const CreateAccountResponse*>(
               &_CreateAccountResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreateAccountResponse& a, CreateAccountResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateAccountResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAccountResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateAccountResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateAccountResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateAccountResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateAccountResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAccountResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.CreateAccountResponse";
  }
  protected:
  explicit CreateAccountResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountDescriptorFieldNumber = 1,
    kTransactionFieldNumber = 2,
  };
  // .kvstore.v1.AccountDescriptor account_descriptor = 1 [json_name = "accountDescriptor"];
  bool has_account_descriptor() const;
  private:
  bool _internal_has_account_descriptor() const;
  public:
  void clear_account_descriptor();
  const ::kvstore::v1::AccountDescriptor& account_descriptor() const;
  PROTOBUF_NODISCARD ::kvstore::v1::AccountDescriptor* release_account_descriptor();
  ::kvstore::v1::AccountDescriptor* mutable_account_descriptor();
  void set_allocated_account_descriptor(::kvstore::v1::AccountDescriptor* account_descriptor);
  private:
  const ::kvstore::v1::AccountDescriptor& _internal_account_descriptor() const;
  ::kvstore::v1::AccountDescriptor* _internal_mutable_account_descriptor();
  public:
  void unsafe_arena_set_allocated_account_descriptor(
      ::kvstore::v1::AccountDescriptor* account_descriptor);
  ::kvstore::v1::AccountDescriptor* unsafe_arena_release_account_descriptor();

  // .kvstore.v1.Transaction transaction = 2 [json_name = "transaction"];
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::kvstore::v1::Transaction& transaction() const;
  PROTOBUF_NODISCARD ::kvstore::v1::Transaction* release_transaction();
  ::kvstore::v1::Transaction* mutable_transaction();
  void set_allocated_transaction(::kvstore::v1::Transaction* transaction);
  private:
  const ::kvstore::v1::Transaction& _internal_transaction() const;
  ::kvstore::v1::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::kvstore::v1::Transaction* transaction);
  ::kvstore::v1::Transaction* unsafe_arena_release_transaction();

  // @@protoc_insertion_point(class_scope:kvstore.v1.CreateAccountResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kvstore::v1::AccountDescriptor* account_descriptor_;
  ::kvstore::v1::Transaction* transaction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class DeleteAccountRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.DeleteAccountRequest) */ {
 public:
  inline DeleteAccountRequest() : DeleteAccountRequest(nullptr) {}
  ~DeleteAccountRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteAccountRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteAccountRequest(const DeleteAccountRequest& from);
  DeleteAccountRequest(DeleteAccountRequest&& from) noexcept
    : DeleteAccountRequest() {
    *this = ::std::move(from);
  }

  inline DeleteAccountRequest& operator=(const DeleteAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteAccountRequest& operator=(DeleteAccountRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteAccountRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteAccountRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteAccountRequest*>(
               &_DeleteAccountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DeleteAccountRequest& a, DeleteAccountRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteAccountRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteAccountRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteAccountRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteAccountRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteAccountRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteAccountRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteAccountRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.DeleteAccountRequest";
  }
  protected:
  explicit DeleteAccountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerFieldNumber = 2,
    kTransactionFieldNumber = 3,
    kAccountIdFieldNumber = 1,
  };
  // string owner = 2 [json_name = "owner"];
  void clear_owner();
  const std::string& owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* owner);
  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(const std::string& value);
  std::string* _internal_mutable_owner();
  public:

  // .kvstore.v1.Transaction transaction = 3 [json_name = "transaction"];
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::kvstore::v1::Transaction& transaction() const;
  PROTOBUF_NODISCARD ::kvstore::v1::Transaction* release_transaction();
  ::kvstore::v1::Transaction* mutable_transaction();
  void set_allocated_transaction(::kvstore::v1::Transaction* transaction);
  private:
  const ::kvstore::v1::Transaction& _internal_transaction() const;
  ::kvstore::v1::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::kvstore::v1::Transaction* transaction);
  ::kvstore::v1::Transaction* unsafe_arena_release_transaction();

  // uint64 account_id = 1 [json_name = "accountId"];
  void clear_account_id();
  uint64_t account_id() const;
  void set_account_id(uint64_t value);
  private:
  uint64_t _internal_account_id() const;
  void _internal_set_account_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:kvstore.v1.DeleteAccountRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
  ::kvstore::v1::Transaction* transaction_;
  uint64_t account_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class DeleteAccountResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.DeleteAccountResponse) */ {
 public:
  inline DeleteAccountResponse() : DeleteAccountResponse(nullptr) {}
  ~DeleteAccountResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteAccountResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteAccountResponse(const DeleteAccountResponse& from);
  DeleteAccountResponse(DeleteAccountResponse&& from) noexcept
    : DeleteAccountResponse() {
    *this = ::std::move(from);
  }

  inline DeleteAccountResponse& operator=(const DeleteAccountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteAccountResponse& operator=(DeleteAccountResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteAccountResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteAccountResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteAccountResponse*>(
               &_DeleteAccountResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DeleteAccountResponse& a, DeleteAccountResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteAccountResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteAccountResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteAccountResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteAccountResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteAccountResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteAccountResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteAccountResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.DeleteAccountResponse";
  }
  protected:
  explicit DeleteAccountResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // .kvstore.v1.Transaction transaction = 2 [json_name = "transaction"];
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::kvstore::v1::Transaction& transaction() const;
  PROTOBUF_NODISCARD ::kvstore::v1::Transaction* release_transaction();
  ::kvstore::v1::Transaction* mutable_transaction();
  void set_allocated_transaction(::kvstore::v1::Transaction* transaction);
  private:
  const ::kvstore::v1::Transaction& _internal_transaction() const;
  ::kvstore::v1::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::kvstore::v1::Transaction* transaction);
  ::kvstore::v1::Transaction* unsafe_arena_release_transaction();

  // bool ok = 1 [json_name = "ok"];
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:kvstore.v1.DeleteAccountResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kvstore::v1::Transaction* transaction_;
  bool ok_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class GetAccountDescriptorRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.GetAccountDescriptorRequest) */ {
 public:
  inline GetAccountDescriptorRequest() : GetAccountDescriptorRequest(nullptr) {}
  ~GetAccountDescriptorRequest() override;
  explicit PROTOBUF_CONSTEXPR GetAccountDescriptorRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAccountDescriptorRequest(const GetAccountDescriptorRequest& from);
  GetAccountDescriptorRequest(GetAccountDescriptorRequest&& from) noexcept
    : GetAccountDescriptorRequest() {
    *this = ::std::move(from);
  }

  inline GetAccountDescriptorRequest& operator=(const GetAccountDescriptorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAccountDescriptorRequest& operator=(GetAccountDescriptorRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAccountDescriptorRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAccountDescriptorRequest* internal_default_instance() {
    return reinterpret_cast<const GetAccountDescriptorRequest*>(
               &_GetAccountDescriptorRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetAccountDescriptorRequest& a, GetAccountDescriptorRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAccountDescriptorRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAccountDescriptorRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAccountDescriptorRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAccountDescriptorRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAccountDescriptorRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetAccountDescriptorRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAccountDescriptorRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.GetAccountDescriptorRequest";
  }
  protected:
  explicit GetAccountDescriptorRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 1,
  };
  // uint64 account_id = 1 [json_name = "accountId"];
  void clear_account_id();
  uint64_t account_id() const;
  void set_account_id(uint64_t value);
  private:
  uint64_t _internal_account_id() const;
  void _internal_set_account_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:kvstore.v1.GetAccountDescriptorRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t account_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class GetAccountDescriptorResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.GetAccountDescriptorResponse) */ {
 public:
  inline GetAccountDescriptorResponse() : GetAccountDescriptorResponse(nullptr) {}
  ~GetAccountDescriptorResponse() override;
  explicit PROTOBUF_CONSTEXPR GetAccountDescriptorResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAccountDescriptorResponse(const GetAccountDescriptorResponse& from);
  GetAccountDescriptorResponse(GetAccountDescriptorResponse&& from) noexcept
    : GetAccountDescriptorResponse() {
    *this = ::std::move(from);
  }

  inline GetAccountDescriptorResponse& operator=(const GetAccountDescriptorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAccountDescriptorResponse& operator=(GetAccountDescriptorResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAccountDescriptorResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAccountDescriptorResponse* internal_default_instance() {
    return reinterpret_cast<const GetAccountDescriptorResponse*>(
               &_GetAccountDescriptorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetAccountDescriptorResponse& a, GetAccountDescriptorResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAccountDescriptorResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAccountDescriptorResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAccountDescriptorResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAccountDescriptorResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAccountDescriptorResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetAccountDescriptorResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAccountDescriptorResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.GetAccountDescriptorResponse";
  }
  protected:
  explicit GetAccountDescriptorResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountDescriptorFieldNumber = 1,
  };
  // .kvstore.v1.AccountDescriptor account_descriptor = 1 [json_name = "accountDescriptor"];
  bool has_account_descriptor() const;
  private:
  bool _internal_has_account_descriptor() const;
  public:
  void clear_account_descriptor();
  const ::kvstore::v1::AccountDescriptor& account_descriptor() const;
  PROTOBUF_NODISCARD ::kvstore::v1::AccountDescriptor* release_account_descriptor();
  ::kvstore::v1::AccountDescriptor* mutable_account_descriptor();
  void set_allocated_account_descriptor(::kvstore::v1::AccountDescriptor* account_descriptor);
  private:
  const ::kvstore::v1::AccountDescriptor& _internal_account_descriptor() const;
  ::kvstore::v1::AccountDescriptor* _internal_mutable_account_descriptor();
  public:
  void unsafe_arena_set_allocated_account_descriptor(
      ::kvstore::v1::AccountDescriptor* account_descriptor);
  ::kvstore::v1::AccountDescriptor* unsafe_arena_release_account_descriptor();

  // @@protoc_insertion_point(class_scope:kvstore.v1.GetAccountDescriptorResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kvstore::v1::AccountDescriptor* account_descriptor_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class AccountDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.AccountDescriptor) */ {
 public:
  inline AccountDescriptor() : AccountDescriptor(nullptr) {}
  ~AccountDescriptor() override;
  explicit PROTOBUF_CONSTEXPR AccountDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountDescriptor(const AccountDescriptor& from);
  AccountDescriptor(AccountDescriptor&& from) noexcept
    : AccountDescriptor() {
    *this = ::std::move(from);
  }

  inline AccountDescriptor& operator=(const AccountDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountDescriptor& operator=(AccountDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountDescriptor* internal_default_instance() {
    return reinterpret_cast<const AccountDescriptor*>(
               &_AccountDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AccountDescriptor& a, AccountDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AccountDescriptor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.AccountDescriptor";
  }
  protected:
  explicit AccountDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBucketsFieldNumber = 6,
    kOwnerFieldNumber = 2,
    kCreatedFieldNumber = 3,
    kLastUpdatedFieldNumber = 4,
    kAccountIdFieldNumber = 1,
    kBucketCountFieldNumber = 5,
  };
  // repeated string buckets = 6 [json_name = "buckets"];
  int buckets_size() const;
  private:
  int _internal_buckets_size() const;
  public:
  void clear_buckets();
  const std::string& buckets(int index) const;
  std::string* mutable_buckets(int index);
  void set_buckets(int index, const std::string& value);
  void set_buckets(int index, std::string&& value);
  void set_buckets(int index, const char* value);
  void set_buckets(int index, const char* value, size_t size);
  std::string* add_buckets();
  void add_buckets(const std::string& value);
  void add_buckets(std::string&& value);
  void add_buckets(const char* value);
  void add_buckets(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& buckets() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_buckets();
  private:
  const std::string& _internal_buckets(int index) const;
  std::string* _internal_add_buckets();
  public:

  // string owner = 2 [json_name = "owner"];
  void clear_owner();
  const std::string& owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* owner);
  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(const std::string& value);
  std::string* _internal_mutable_owner();
  public:

  // .google.protobuf.Timestamp created = 3 [json_name = "created"];
  bool has_created() const;
  private:
  bool _internal_has_created() const;
  public:
  void clear_created();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created();
  void set_allocated_created(::PROTOBUF_NAMESPACE_ID::Timestamp* created);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created();
  public:
  void unsafe_arena_set_allocated_created(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created();

  // .google.protobuf.Timestamp last_updated = 4 [json_name = "lastUpdated"];
  bool has_last_updated() const;
  private:
  bool _internal_has_last_updated() const;
  public:
  void clear_last_updated();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_updated() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_updated();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_updated();
  void set_allocated_last_updated(::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_updated() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_updated();
  public:
  void unsafe_arena_set_allocated_last_updated(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_updated();

  // uint64 account_id = 1 [json_name = "accountId"];
  void clear_account_id();
  uint64_t account_id() const;
  void set_account_id(uint64_t value);
  private:
  uint64_t _internal_account_id() const;
  void _internal_set_account_id(uint64_t value);
  public:

  // uint64 bucket_count = 5 [json_name = "bucketCount"];
  void clear_bucket_count();
  uint64_t bucket_count() const;
  void set_bucket_count(uint64_t value);
  private:
  uint64_t _internal_bucket_count() const;
  void _internal_set_bucket_count(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:kvstore.v1.AccountDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> buckets_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated_;
  uint64_t account_id_;
  uint64_t bucket_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class CreateBucketRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.CreateBucketRequest) */ {
 public:
  inline CreateBucketRequest() : CreateBucketRequest(nullptr) {}
  ~CreateBucketRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateBucketRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateBucketRequest(const CreateBucketRequest& from);
  CreateBucketRequest(CreateBucketRequest&& from) noexcept
    : CreateBucketRequest() {
    *this = ::std::move(from);
  }

  inline CreateBucketRequest& operator=(const CreateBucketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateBucketRequest& operator=(CreateBucketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateBucketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateBucketRequest* internal_default_instance() {
    return reinterpret_cast<const CreateBucketRequest*>(
               &_CreateBucketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CreateBucketRequest& a, CreateBucketRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateBucketRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateBucketRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateBucketRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateBucketRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateBucketRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateBucketRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateBucketRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.CreateBucketRequest";
  }
  protected:
  explicit CreateBucketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kOwnerFieldNumber = 3,
    kTransactionFieldNumber = 4,
    kAccountIdFieldNumber = 1,
  };
  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string owner = 3 [json_name = "owner"];
  void clear_owner();
  const std::string& owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* owner);
  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(const std::string& value);
  std::string* _internal_mutable_owner();
  public:

  // .kvstore.v1.Transaction transaction = 4 [json_name = "transaction"];
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::kvstore::v1::Transaction& transaction() const;
  PROTOBUF_NODISCARD ::kvstore::v1::Transaction* release_transaction();
  ::kvstore::v1::Transaction* mutable_transaction();
  void set_allocated_transaction(::kvstore::v1::Transaction* transaction);
  private:
  const ::kvstore::v1::Transaction& _internal_transaction() const;
  ::kvstore::v1::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::kvstore::v1::Transaction* transaction);
  ::kvstore::v1::Transaction* unsafe_arena_release_transaction();

  // uint64 account_id = 1 [json_name = "accountId"];
  void clear_account_id();
  uint64_t account_id() const;
  void set_account_id(uint64_t value);
  private:
  uint64_t _internal_account_id() const;
  void _internal_set_account_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:kvstore.v1.CreateBucketRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
  ::kvstore::v1::Transaction* transaction_;
  uint64_t account_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class CreateBucketResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.CreateBucketResponse) */ {
 public:
  inline CreateBucketResponse() : CreateBucketResponse(nullptr) {}
  ~CreateBucketResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateBucketResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateBucketResponse(const CreateBucketResponse& from);
  CreateBucketResponse(CreateBucketResponse&& from) noexcept
    : CreateBucketResponse() {
    *this = ::std::move(from);
  }

  inline CreateBucketResponse& operator=(const CreateBucketResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateBucketResponse& operator=(CreateBucketResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateBucketResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateBucketResponse* internal_default_instance() {
    return reinterpret_cast<const CreateBucketResponse*>(
               &_CreateBucketResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CreateBucketResponse& a, CreateBucketResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateBucketResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateBucketResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateBucketResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateBucketResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateBucketResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateBucketResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateBucketResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.CreateBucketResponse";
  }
  protected:
  explicit CreateBucketResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBucketDescriptorFieldNumber = 1,
    kTransactionFieldNumber = 2,
  };
  // .kvstore.v1.BucketDescriptor bucket_descriptor = 1 [json_name = "bucketDescriptor"];
  bool has_bucket_descriptor() const;
  private:
  bool _internal_has_bucket_descriptor() const;
  public:
  void clear_bucket_descriptor();
  const ::kvstore::v1::BucketDescriptor& bucket_descriptor() const;
  PROTOBUF_NODISCARD ::kvstore::v1::BucketDescriptor* release_bucket_descriptor();
  ::kvstore::v1::BucketDescriptor* mutable_bucket_descriptor();
  void set_allocated_bucket_descriptor(::kvstore::v1::BucketDescriptor* bucket_descriptor);
  private:
  const ::kvstore::v1::BucketDescriptor& _internal_bucket_descriptor() const;
  ::kvstore::v1::BucketDescriptor* _internal_mutable_bucket_descriptor();
  public:
  void unsafe_arena_set_allocated_bucket_descriptor(
      ::kvstore::v1::BucketDescriptor* bucket_descriptor);
  ::kvstore::v1::BucketDescriptor* unsafe_arena_release_bucket_descriptor();

  // .kvstore.v1.Transaction transaction = 2 [json_name = "transaction"];
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::kvstore::v1::Transaction& transaction() const;
  PROTOBUF_NODISCARD ::kvstore::v1::Transaction* release_transaction();
  ::kvstore::v1::Transaction* mutable_transaction();
  void set_allocated_transaction(::kvstore::v1::Transaction* transaction);
  private:
  const ::kvstore::v1::Transaction& _internal_transaction() const;
  ::kvstore::v1::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::kvstore::v1::Transaction* transaction);
  ::kvstore::v1::Transaction* unsafe_arena_release_transaction();

  // @@protoc_insertion_point(class_scope:kvstore.v1.CreateBucketResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kvstore::v1::BucketDescriptor* bucket_descriptor_;
  ::kvstore::v1::Transaction* transaction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class DeleteBucketRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.DeleteBucketRequest) */ {
 public:
  inline DeleteBucketRequest() : DeleteBucketRequest(nullptr) {}
  ~DeleteBucketRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteBucketRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteBucketRequest(const DeleteBucketRequest& from);
  DeleteBucketRequest(DeleteBucketRequest&& from) noexcept
    : DeleteBucketRequest() {
    *this = ::std::move(from);
  }

  inline DeleteBucketRequest& operator=(const DeleteBucketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteBucketRequest& operator=(DeleteBucketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteBucketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteBucketRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteBucketRequest*>(
               &_DeleteBucketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DeleteBucketRequest& a, DeleteBucketRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteBucketRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteBucketRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteBucketRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteBucketRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteBucketRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteBucketRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteBucketRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.DeleteBucketRequest";
  }
  protected:
  explicit DeleteBucketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kTransactionFieldNumber = 3,
    kAccountIdFieldNumber = 1,
  };
  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .kvstore.v1.Transaction transaction = 3 [json_name = "transaction"];
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::kvstore::v1::Transaction& transaction() const;
  PROTOBUF_NODISCARD ::kvstore::v1::Transaction* release_transaction();
  ::kvstore::v1::Transaction* mutable_transaction();
  void set_allocated_transaction(::kvstore::v1::Transaction* transaction);
  private:
  const ::kvstore::v1::Transaction& _internal_transaction() const;
  ::kvstore::v1::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::kvstore::v1::Transaction* transaction);
  ::kvstore::v1::Transaction* unsafe_arena_release_transaction();

  // uint64 account_id = 1 [json_name = "accountId"];
  void clear_account_id();
  uint64_t account_id() const;
  void set_account_id(uint64_t value);
  private:
  uint64_t _internal_account_id() const;
  void _internal_set_account_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:kvstore.v1.DeleteBucketRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::kvstore::v1::Transaction* transaction_;
  uint64_t account_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class DeleteBucketResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.DeleteBucketResponse) */ {
 public:
  inline DeleteBucketResponse() : DeleteBucketResponse(nullptr) {}
  ~DeleteBucketResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteBucketResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteBucketResponse(const DeleteBucketResponse& from);
  DeleteBucketResponse(DeleteBucketResponse&& from) noexcept
    : DeleteBucketResponse() {
    *this = ::std::move(from);
  }

  inline DeleteBucketResponse& operator=(const DeleteBucketResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteBucketResponse& operator=(DeleteBucketResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteBucketResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteBucketResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteBucketResponse*>(
               &_DeleteBucketResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DeleteBucketResponse& a, DeleteBucketResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteBucketResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteBucketResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteBucketResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteBucketResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteBucketResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteBucketResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteBucketResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.DeleteBucketResponse";
  }
  protected:
  explicit DeleteBucketResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // .kvstore.v1.Transaction transaction = 2 [json_name = "transaction"];
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::kvstore::v1::Transaction& transaction() const;
  PROTOBUF_NODISCARD ::kvstore::v1::Transaction* release_transaction();
  ::kvstore::v1::Transaction* mutable_transaction();
  void set_allocated_transaction(::kvstore::v1::Transaction* transaction);
  private:
  const ::kvstore::v1::Transaction& _internal_transaction() const;
  ::kvstore::v1::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::kvstore::v1::Transaction* transaction);
  ::kvstore::v1::Transaction* unsafe_arena_release_transaction();

  // bool ok = 1 [json_name = "ok"];
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:kvstore.v1.DeleteBucketResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kvstore::v1::Transaction* transaction_;
  bool ok_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class BucketDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.BucketDescriptor) */ {
 public:
  inline BucketDescriptor() : BucketDescriptor(nullptr) {}
  ~BucketDescriptor() override;
  explicit PROTOBUF_CONSTEXPR BucketDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BucketDescriptor(const BucketDescriptor& from);
  BucketDescriptor(BucketDescriptor&& from) noexcept
    : BucketDescriptor() {
    *this = ::std::move(from);
  }

  inline BucketDescriptor& operator=(const BucketDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline BucketDescriptor& operator=(BucketDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BucketDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const BucketDescriptor* internal_default_instance() {
    return reinterpret_cast<const BucketDescriptor*>(
               &_BucketDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(BucketDescriptor& a, BucketDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(BucketDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BucketDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BucketDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BucketDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BucketDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BucketDescriptor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BucketDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.BucketDescriptor";
  }
  protected:
  explicit BucketDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerFieldNumber = 1,
    kCreatedFieldNumber = 4,
    kLastUpdatedFieldNumber = 5,
    kSizeFieldNumber = 2,
    kKeyCountFieldNumber = 3,
  };
  // string owner = 1 [json_name = "owner"];
  void clear_owner();
  const std::string& owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* owner);
  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(const std::string& value);
  std::string* _internal_mutable_owner();
  public:

  // .google.protobuf.Timestamp created = 4 [json_name = "created"];
  bool has_created() const;
  private:
  bool _internal_has_created() const;
  public:
  void clear_created();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created();
  void set_allocated_created(::PROTOBUF_NAMESPACE_ID::Timestamp* created);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created();
  public:
  void unsafe_arena_set_allocated_created(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created();

  // .google.protobuf.Timestamp last_updated = 5 [json_name = "lastUpdated"];
  bool has_last_updated() const;
  private:
  bool _internal_has_last_updated() const;
  public:
  void clear_last_updated();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_updated() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_updated();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_updated();
  void set_allocated_last_updated(::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_updated() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_updated();
  public:
  void unsafe_arena_set_allocated_last_updated(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_updated();

  // uint64 size = 2 [json_name = "size"];
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // uint64 key_count = 3 [json_name = "keyCount"];
  void clear_key_count();
  uint64_t key_count() const;
  void set_key_count(uint64_t value);
  private:
  uint64_t _internal_key_count() const;
  void _internal_set_key_count(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:kvstore.v1.BucketDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated_;
  uint64_t size_;
  uint64_t key_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class GetBucketDescriptorRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.GetBucketDescriptorRequest) */ {
 public:
  inline GetBucketDescriptorRequest() : GetBucketDescriptorRequest(nullptr) {}
  ~GetBucketDescriptorRequest() override;
  explicit PROTOBUF_CONSTEXPR GetBucketDescriptorRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBucketDescriptorRequest(const GetBucketDescriptorRequest& from);
  GetBucketDescriptorRequest(GetBucketDescriptorRequest&& from) noexcept
    : GetBucketDescriptorRequest() {
    *this = ::std::move(from);
  }

  inline GetBucketDescriptorRequest& operator=(const GetBucketDescriptorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBucketDescriptorRequest& operator=(GetBucketDescriptorRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBucketDescriptorRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBucketDescriptorRequest* internal_default_instance() {
    return reinterpret_cast<const GetBucketDescriptorRequest*>(
               &_GetBucketDescriptorRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetBucketDescriptorRequest& a, GetBucketDescriptorRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBucketDescriptorRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBucketDescriptorRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBucketDescriptorRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBucketDescriptorRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBucketDescriptorRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBucketDescriptorRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBucketDescriptorRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.GetBucketDescriptorRequest";
  }
  protected:
  explicit GetBucketDescriptorRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBucketNameFieldNumber = 2,
    kAccountIdFieldNumber = 1,
  };
  // string bucket_name = 2 [json_name = "bucketName"];
  void clear_bucket_name();
  const std::string& bucket_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bucket_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bucket_name();
  PROTOBUF_NODISCARD std::string* release_bucket_name();
  void set_allocated_bucket_name(std::string* bucket_name);
  private:
  const std::string& _internal_bucket_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bucket_name(const std::string& value);
  std::string* _internal_mutable_bucket_name();
  public:

  // uint64 account_id = 1 [json_name = "accountId"];
  void clear_account_id();
  uint64_t account_id() const;
  void set_account_id(uint64_t value);
  private:
  uint64_t _internal_account_id() const;
  void _internal_set_account_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:kvstore.v1.GetBucketDescriptorRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bucket_name_;
  uint64_t account_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class GetBucketDescriptorResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.GetBucketDescriptorResponse) */ {
 public:
  inline GetBucketDescriptorResponse() : GetBucketDescriptorResponse(nullptr) {}
  ~GetBucketDescriptorResponse() override;
  explicit PROTOBUF_CONSTEXPR GetBucketDescriptorResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBucketDescriptorResponse(const GetBucketDescriptorResponse& from);
  GetBucketDescriptorResponse(GetBucketDescriptorResponse&& from) noexcept
    : GetBucketDescriptorResponse() {
    *this = ::std::move(from);
  }

  inline GetBucketDescriptorResponse& operator=(const GetBucketDescriptorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBucketDescriptorResponse& operator=(GetBucketDescriptorResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBucketDescriptorResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBucketDescriptorResponse* internal_default_instance() {
    return reinterpret_cast<const GetBucketDescriptorResponse*>(
               &_GetBucketDescriptorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetBucketDescriptorResponse& a, GetBucketDescriptorResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBucketDescriptorResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBucketDescriptorResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBucketDescriptorResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBucketDescriptorResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBucketDescriptorResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBucketDescriptorResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBucketDescriptorResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.GetBucketDescriptorResponse";
  }
  protected:
  explicit GetBucketDescriptorResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBucketDescriptorFieldNumber = 1,
  };
  // .kvstore.v1.BucketDescriptor bucket_descriptor = 1 [json_name = "bucketDescriptor"];
  bool has_bucket_descriptor() const;
  private:
  bool _internal_has_bucket_descriptor() const;
  public:
  void clear_bucket_descriptor();
  const ::kvstore::v1::BucketDescriptor& bucket_descriptor() const;
  PROTOBUF_NODISCARD ::kvstore::v1::BucketDescriptor* release_bucket_descriptor();
  ::kvstore::v1::BucketDescriptor* mutable_bucket_descriptor();
  void set_allocated_bucket_descriptor(::kvstore::v1::BucketDescriptor* bucket_descriptor);
  private:
  const ::kvstore::v1::BucketDescriptor& _internal_bucket_descriptor() const;
  ::kvstore::v1::BucketDescriptor* _internal_mutable_bucket_descriptor();
  public:
  void unsafe_arena_set_allocated_bucket_descriptor(
      ::kvstore::v1::BucketDescriptor* bucket_descriptor);
  ::kvstore::v1::BucketDescriptor* unsafe_arena_release_bucket_descriptor();

  // @@protoc_insertion_point(class_scope:kvstore.v1.GetBucketDescriptorResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kvstore::v1::BucketDescriptor* bucket_descriptor_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class GetKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.GetKeyRequest) */ {
 public:
  inline GetKeyRequest() : GetKeyRequest(nullptr) {}
  ~GetKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR GetKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetKeyRequest(const GetKeyRequest& from);
  GetKeyRequest(GetKeyRequest&& from) noexcept
    : GetKeyRequest() {
    *this = ::std::move(from);
  }

  inline GetKeyRequest& operator=(const GetKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetKeyRequest& operator=(GetKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetKeyRequest* internal_default_instance() {
    return reinterpret_cast<const GetKeyRequest*>(
               &_GetKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetKeyRequest& a, GetKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetKeyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.GetKeyRequest";
  }
  protected:
  explicit GetKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBucketNameFieldNumber = 2,
    kKeyFieldNumber = 3,
    kAccountIdFieldNumber = 1,
    kVersionFieldNumber = 4,
  };
  // string bucket_name = 2 [json_name = "bucketName"];
  void clear_bucket_name();
  const std::string& bucket_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bucket_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bucket_name();
  PROTOBUF_NODISCARD std::string* release_bucket_name();
  void set_allocated_bucket_name(std::string* bucket_name);
  private:
  const std::string& _internal_bucket_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bucket_name(const std::string& value);
  std::string* _internal_mutable_bucket_name();
  public:

  // bytes key = 3 [json_name = "key"];
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // uint64 account_id = 1 [json_name = "accountId"];
  void clear_account_id();
  uint64_t account_id() const;
  void set_account_id(uint64_t value);
  private:
  uint64_t _internal_account_id() const;
  void _internal_set_account_id(uint64_t value);
  public:

  // optional uint32 version = 4 [json_name = "version"];
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:kvstore.v1.GetKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bucket_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  uint64_t account_id_;
  uint32_t version_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class GetKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.GetKeyResponse) */ {
 public:
  inline GetKeyResponse() : GetKeyResponse(nullptr) {}
  ~GetKeyResponse() override;
  explicit PROTOBUF_CONSTEXPR GetKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetKeyResponse(const GetKeyResponse& from);
  GetKeyResponse(GetKeyResponse&& from) noexcept
    : GetKeyResponse() {
    *this = ::std::move(from);
  }

  inline GetKeyResponse& operator=(const GetKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetKeyResponse& operator=(GetKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetKeyResponse* internal_default_instance() {
    return reinterpret_cast<const GetKeyResponse*>(
               &_GetKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetKeyResponse& a, GetKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetKeyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetKeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetKeyResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetKeyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.GetKeyResponse";
  }
  protected:
  explicit GetKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyValuePairFieldNumber = 1,
  };
  // .kvstore.v1.KeyValue key_value_pair = 1 [json_name = "keyValuePair"];
  bool has_key_value_pair() const;
  private:
  bool _internal_has_key_value_pair() const;
  public:
  void clear_key_value_pair();
  const ::kvstore::v1::KeyValue& key_value_pair() const;
  PROTOBUF_NODISCARD ::kvstore::v1::KeyValue* release_key_value_pair();
  ::kvstore::v1::KeyValue* mutable_key_value_pair();
  void set_allocated_key_value_pair(::kvstore::v1::KeyValue* key_value_pair);
  private:
  const ::kvstore::v1::KeyValue& _internal_key_value_pair() const;
  ::kvstore::v1::KeyValue* _internal_mutable_key_value_pair();
  public:
  void unsafe_arena_set_allocated_key_value_pair(
      ::kvstore::v1::KeyValue* key_value_pair);
  ::kvstore::v1::KeyValue* unsafe_arena_release_key_value_pair();

  // @@protoc_insertion_point(class_scope:kvstore.v1.GetKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kvstore::v1::KeyValue* key_value_pair_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class PutKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.PutKeyRequest) */ {
 public:
  inline PutKeyRequest() : PutKeyRequest(nullptr) {}
  ~PutKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR PutKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutKeyRequest(const PutKeyRequest& from);
  PutKeyRequest(PutKeyRequest&& from) noexcept
    : PutKeyRequest() {
    *this = ::std::move(from);
  }

  inline PutKeyRequest& operator=(const PutKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutKeyRequest& operator=(PutKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutKeyRequest* internal_default_instance() {
    return reinterpret_cast<const PutKeyRequest*>(
               &_PutKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PutKeyRequest& a, PutKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PutKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PutKeyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.PutKeyRequest";
  }
  protected:
  explicit PutKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBucketNameFieldNumber = 2,
    kKeyValuePairFieldNumber = 3,
    kTransactionFieldNumber = 4,
    kAccountIdFieldNumber = 1,
  };
  // string bucket_name = 2 [json_name = "bucketName"];
  void clear_bucket_name();
  const std::string& bucket_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bucket_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bucket_name();
  PROTOBUF_NODISCARD std::string* release_bucket_name();
  void set_allocated_bucket_name(std::string* bucket_name);
  private:
  const std::string& _internal_bucket_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bucket_name(const std::string& value);
  std::string* _internal_mutable_bucket_name();
  public:

  // .kvstore.v1.KeyValue key_value_pair = 3 [json_name = "keyValuePair"];
  bool has_key_value_pair() const;
  private:
  bool _internal_has_key_value_pair() const;
  public:
  void clear_key_value_pair();
  const ::kvstore::v1::KeyValue& key_value_pair() const;
  PROTOBUF_NODISCARD ::kvstore::v1::KeyValue* release_key_value_pair();
  ::kvstore::v1::KeyValue* mutable_key_value_pair();
  void set_allocated_key_value_pair(::kvstore::v1::KeyValue* key_value_pair);
  private:
  const ::kvstore::v1::KeyValue& _internal_key_value_pair() const;
  ::kvstore::v1::KeyValue* _internal_mutable_key_value_pair();
  public:
  void unsafe_arena_set_allocated_key_value_pair(
      ::kvstore::v1::KeyValue* key_value_pair);
  ::kvstore::v1::KeyValue* unsafe_arena_release_key_value_pair();

  // .kvstore.v1.Transaction transaction = 4 [json_name = "transaction"];
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::kvstore::v1::Transaction& transaction() const;
  PROTOBUF_NODISCARD ::kvstore::v1::Transaction* release_transaction();
  ::kvstore::v1::Transaction* mutable_transaction();
  void set_allocated_transaction(::kvstore::v1::Transaction* transaction);
  private:
  const ::kvstore::v1::Transaction& _internal_transaction() const;
  ::kvstore::v1::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::kvstore::v1::Transaction* transaction);
  ::kvstore::v1::Transaction* unsafe_arena_release_transaction();

  // uint64 account_id = 1 [json_name = "accountId"];
  void clear_account_id();
  uint64_t account_id() const;
  void set_account_id(uint64_t value);
  private:
  uint64_t _internal_account_id() const;
  void _internal_set_account_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:kvstore.v1.PutKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bucket_name_;
  ::kvstore::v1::KeyValue* key_value_pair_;
  ::kvstore::v1::Transaction* transaction_;
  uint64_t account_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class PutKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.PutKeyResponse) */ {
 public:
  inline PutKeyResponse() : PutKeyResponse(nullptr) {}
  ~PutKeyResponse() override;
  explicit PROTOBUF_CONSTEXPR PutKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutKeyResponse(const PutKeyResponse& from);
  PutKeyResponse(PutKeyResponse&& from) noexcept
    : PutKeyResponse() {
    *this = ::std::move(from);
  }

  inline PutKeyResponse& operator=(const PutKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutKeyResponse& operator=(PutKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutKeyResponse* internal_default_instance() {
    return reinterpret_cast<const PutKeyResponse*>(
               &_PutKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PutKeyResponse& a, PutKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PutKeyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutKeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PutKeyResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutKeyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.PutKeyResponse";
  }
  protected:
  explicit PutKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionFieldNumber = 1,
  };
  // .kvstore.v1.Transaction transaction = 1 [json_name = "transaction"];
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::kvstore::v1::Transaction& transaction() const;
  PROTOBUF_NODISCARD ::kvstore::v1::Transaction* release_transaction();
  ::kvstore::v1::Transaction* mutable_transaction();
  void set_allocated_transaction(::kvstore::v1::Transaction* transaction);
  private:
  const ::kvstore::v1::Transaction& _internal_transaction() const;
  ::kvstore::v1::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::kvstore::v1::Transaction* transaction);
  ::kvstore::v1::Transaction* unsafe_arena_release_transaction();

  // @@protoc_insertion_point(class_scope:kvstore.v1.PutKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kvstore::v1::Transaction* transaction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class DeleteKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.DeleteKeyRequest) */ {
 public:
  inline DeleteKeyRequest() : DeleteKeyRequest(nullptr) {}
  ~DeleteKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteKeyRequest(const DeleteKeyRequest& from);
  DeleteKeyRequest(DeleteKeyRequest&& from) noexcept
    : DeleteKeyRequest() {
    *this = ::std::move(from);
  }

  inline DeleteKeyRequest& operator=(const DeleteKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteKeyRequest& operator=(DeleteKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteKeyRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteKeyRequest*>(
               &_DeleteKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(DeleteKeyRequest& a, DeleteKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteKeyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.DeleteKeyRequest";
  }
  protected:
  explicit DeleteKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBucketNameFieldNumber = 2,
    kKeyFieldNumber = 3,
    kTransactionFieldNumber = 4,
    kAccountIdFieldNumber = 1,
  };
  // string bucket_name = 2 [json_name = "bucketName"];
  void clear_bucket_name();
  const std::string& bucket_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bucket_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bucket_name();
  PROTOBUF_NODISCARD std::string* release_bucket_name();
  void set_allocated_bucket_name(std::string* bucket_name);
  private:
  const std::string& _internal_bucket_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bucket_name(const std::string& value);
  std::string* _internal_mutable_bucket_name();
  public:

  // bytes key = 3 [json_name = "key"];
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .kvstore.v1.Transaction transaction = 4 [json_name = "transaction"];
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::kvstore::v1::Transaction& transaction() const;
  PROTOBUF_NODISCARD ::kvstore::v1::Transaction* release_transaction();
  ::kvstore::v1::Transaction* mutable_transaction();
  void set_allocated_transaction(::kvstore::v1::Transaction* transaction);
  private:
  const ::kvstore::v1::Transaction& _internal_transaction() const;
  ::kvstore::v1::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::kvstore::v1::Transaction* transaction);
  ::kvstore::v1::Transaction* unsafe_arena_release_transaction();

  // uint64 account_id = 1 [json_name = "accountId"];
  void clear_account_id();
  uint64_t account_id() const;
  void set_account_id(uint64_t value);
  private:
  uint64_t _internal_account_id() const;
  void _internal_set_account_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:kvstore.v1.DeleteKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bucket_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::kvstore::v1::Transaction* transaction_;
  uint64_t account_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class DeleteKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.DeleteKeyResponse) */ {
 public:
  inline DeleteKeyResponse() : DeleteKeyResponse(nullptr) {}
  ~DeleteKeyResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteKeyResponse(const DeleteKeyResponse& from);
  DeleteKeyResponse(DeleteKeyResponse&& from) noexcept
    : DeleteKeyResponse() {
    *this = ::std::move(from);
  }

  inline DeleteKeyResponse& operator=(const DeleteKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteKeyResponse& operator=(DeleteKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteKeyResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteKeyResponse*>(
               &_DeleteKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(DeleteKeyResponse& a, DeleteKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteKeyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteKeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteKeyResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteKeyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.DeleteKeyResponse";
  }
  protected:
  explicit DeleteKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionFieldNumber = 3,
    kOkFieldNumber = 1,
  };
  // .kvstore.v1.Transaction transaction = 3 [json_name = "transaction"];
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::kvstore::v1::Transaction& transaction() const;
  PROTOBUF_NODISCARD ::kvstore::v1::Transaction* release_transaction();
  ::kvstore::v1::Transaction* mutable_transaction();
  void set_allocated_transaction(::kvstore::v1::Transaction* transaction);
  private:
  const ::kvstore::v1::Transaction& _internal_transaction() const;
  ::kvstore::v1::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::kvstore::v1::Transaction* transaction);
  ::kvstore::v1::Transaction* unsafe_arena_release_transaction();

  // bool ok = 1 [json_name = "ok"];
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:kvstore.v1.DeleteKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::kvstore::v1::Transaction* transaction_;
  bool ok_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class KeyValueDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.KeyValueDescriptor) */ {
 public:
  inline KeyValueDescriptor() : KeyValueDescriptor(nullptr) {}
  ~KeyValueDescriptor() override;
  explicit PROTOBUF_CONSTEXPR KeyValueDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyValueDescriptor(const KeyValueDescriptor& from);
  KeyValueDescriptor(KeyValueDescriptor&& from) noexcept
    : KeyValueDescriptor() {
    *this = ::std::move(from);
  }

  inline KeyValueDescriptor& operator=(const KeyValueDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyValueDescriptor& operator=(KeyValueDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyValueDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyValueDescriptor* internal_default_instance() {
    return reinterpret_cast<const KeyValueDescriptor*>(
               &_KeyValueDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(KeyValueDescriptor& a, KeyValueDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyValueDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyValueDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyValueDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyValueDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyValueDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KeyValueDescriptor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyValueDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.KeyValueDescriptor";
  }
  protected:
  explicit KeyValueDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionsFieldNumber = 1,
    kCurrentKeyFieldNumber = 2,
  };
  // repeated uint32 versions = 1 [json_name = "versions"];
  int versions_size() const;
  private:
  int _internal_versions_size() const;
  public:
  void clear_versions();
  private:
  uint32_t _internal_versions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_versions() const;
  void _internal_add_versions(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_versions();
  public:
  uint32_t versions(int index) const;
  void set_versions(int index, uint32_t value);
  void add_versions(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      versions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_versions();

  // bytes current_key = 2 [json_name = "currentKey"];
  void clear_current_key();
  const std::string& current_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_current_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_current_key();
  PROTOBUF_NODISCARD std::string* release_current_key();
  void set_allocated_current_key(std::string* current_key);
  private:
  const std::string& _internal_current_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_key(const std::string& value);
  std::string* _internal_mutable_current_key();
  public:

  // @@protoc_insertion_point(class_scope:kvstore.v1.KeyValueDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > versions_;
  mutable std::atomic<int> _versions_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class ListKeyVersionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.ListKeyVersionsRequest) */ {
 public:
  inline ListKeyVersionsRequest() : ListKeyVersionsRequest(nullptr) {}
  ~ListKeyVersionsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListKeyVersionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListKeyVersionsRequest(const ListKeyVersionsRequest& from);
  ListKeyVersionsRequest(ListKeyVersionsRequest&& from) noexcept
    : ListKeyVersionsRequest() {
    *this = ::std::move(from);
  }

  inline ListKeyVersionsRequest& operator=(const ListKeyVersionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListKeyVersionsRequest& operator=(ListKeyVersionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListKeyVersionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListKeyVersionsRequest* internal_default_instance() {
    return reinterpret_cast<const ListKeyVersionsRequest*>(
               &_ListKeyVersionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ListKeyVersionsRequest& a, ListKeyVersionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListKeyVersionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListKeyVersionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListKeyVersionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListKeyVersionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListKeyVersionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListKeyVersionsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListKeyVersionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.ListKeyVersionsRequest";
  }
  protected:
  explicit ListKeyVersionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // bytes key = 1 [json_name = "key"];
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:kvstore.v1.ListKeyVersionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class ListKeyVersionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.ListKeyVersionsResponse) */ {
 public:
  inline ListKeyVersionsResponse() : ListKeyVersionsResponse(nullptr) {}
  ~ListKeyVersionsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListKeyVersionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListKeyVersionsResponse(const ListKeyVersionsResponse& from);
  ListKeyVersionsResponse(ListKeyVersionsResponse&& from) noexcept
    : ListKeyVersionsResponse() {
    *this = ::std::move(from);
  }

  inline ListKeyVersionsResponse& operator=(const ListKeyVersionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListKeyVersionsResponse& operator=(ListKeyVersionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListKeyVersionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListKeyVersionsResponse* internal_default_instance() {
    return reinterpret_cast<const ListKeyVersionsResponse*>(
               &_ListKeyVersionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ListKeyVersionsResponse& a, ListKeyVersionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListKeyVersionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListKeyVersionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListKeyVersionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListKeyVersionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListKeyVersionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListKeyVersionsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListKeyVersionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.ListKeyVersionsResponse";
  }
  protected:
  explicit ListKeyVersionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionsFieldNumber = 1,
  };
  // repeated uint32 versions = 1 [json_name = "versions"];
  int versions_size() const;
  private:
  int _internal_versions_size() const;
  public:
  void clear_versions();
  private:
  uint32_t _internal_versions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_versions() const;
  void _internal_add_versions(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_versions();
  public:
  uint32_t versions(int index) const;
  void set_versions(int index, uint32_t value);
  void add_versions(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      versions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_versions();

  // @@protoc_insertion_point(class_scope:kvstore.v1.ListKeyVersionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > versions_;
  mutable std::atomic<int> _versions_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class KeyValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.KeyValue) */ {
 public:
  inline KeyValue() : KeyValue(nullptr) {}
  ~KeyValue() override;
  explicit PROTOBUF_CONSTEXPR KeyValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyValue(const KeyValue& from);
  KeyValue(KeyValue&& from) noexcept
    : KeyValue() {
    *this = ::std::move(from);
  }

  inline KeyValue& operator=(const KeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyValue& operator=(KeyValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyValue* internal_default_instance() {
    return reinterpret_cast<const KeyValue*>(
               &_KeyValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(KeyValue& a, KeyValue& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KeyValue& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.KeyValue";
  }
  protected:
  explicit KeyValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 5,
    kCreateRevisionFieldNumber = 2,
    kModRevisionFieldNumber = 3,
    kVersionFieldNumber = 4,
    kLeaseFieldNumber = 6,
  };
  // bytes key = 1 [json_name = "key"];
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bytes value = 5 [json_name = "value"];
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // int64 create_revision = 2 [json_name = "createRevision"];
  void clear_create_revision();
  int64_t create_revision() const;
  void set_create_revision(int64_t value);
  private:
  int64_t _internal_create_revision() const;
  void _internal_set_create_revision(int64_t value);
  public:

  // int64 mod_revision = 3 [json_name = "modRevision"];
  void clear_mod_revision();
  int64_t mod_revision() const;
  void set_mod_revision(int64_t value);
  private:
  int64_t _internal_mod_revision() const;
  void _internal_set_mod_revision(int64_t value);
  public:

  // uint64 version = 4 [json_name = "version"];
  void clear_version();
  uint64_t version() const;
  void set_version(uint64_t value);
  private:
  uint64_t _internal_version() const;
  void _internal_set_version(uint64_t value);
  public:

  // int64 lease = 6 [json_name = "lease"];
  void clear_lease();
  int64_t lease() const;
  void set_lease(int64_t value);
  private:
  int64_t _internal_lease() const;
  void _internal_set_lease(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:kvstore.v1.KeyValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  int64_t create_revision_;
  int64_t mod_revision_;
  uint64_t version_;
  int64_t lease_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// -------------------------------------------------------------------

class Event final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kvstore.v1.Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() override;
  explicit PROTOBUF_CONSTEXPR Event(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Event& default_instance() {
    return *internal_default_instance();
  }
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Event& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Event& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kvstore.v1.Event";
  }
  protected:
  explicit Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKvFieldNumber = 2,
    kPrevKvFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // .kvstore.v1.KeyValue kv = 2 [json_name = "kv"];
  bool has_kv() const;
  private:
  bool _internal_has_kv() const;
  public:
  void clear_kv();
  const ::kvstore::v1::KeyValue& kv() const;
  PROTOBUF_NODISCARD ::kvstore::v1::KeyValue* release_kv();
  ::kvstore::v1::KeyValue* mutable_kv();
  void set_allocated_kv(::kvstore::v1::KeyValue* kv);
  private:
  const ::kvstore::v1::KeyValue& _internal_kv() const;
  ::kvstore::v1::KeyValue* _internal_mutable_kv();
  public:
  void unsafe_arena_set_allocated_kv(
      ::kvstore::v1::KeyValue* kv);
  ::kvstore::v1::KeyValue* unsafe_arena_release_kv();

  // optional .kvstore.v1.KeyValue prev_kv = 3 [json_name = "prevKv"];
  bool has_prev_kv() const;
  private:
  bool _internal_has_prev_kv() const;
  public:
  void clear_prev_kv();
  const ::kvstore::v1::KeyValue& prev_kv() const;
  PROTOBUF_NODISCARD ::kvstore::v1::KeyValue* release_prev_kv();
  ::kvstore::v1::KeyValue* mutable_prev_kv();
  void set_allocated_prev_kv(::kvstore::v1::KeyValue* prev_kv);
  private:
  const ::kvstore::v1::KeyValue& _internal_prev_kv() const;
  ::kvstore::v1::KeyValue* _internal_mutable_prev_kv();
  public:
  void unsafe_arena_set_allocated_prev_kv(
      ::kvstore::v1::KeyValue* prev_kv);
  ::kvstore::v1::KeyValue* unsafe_arena_release_prev_kv();

  // .kvstore.v1.KeyOperationType type = 1 [json_name = "type"];
  void clear_type();
  ::kvstore::v1::KeyOperationType type() const;
  void set_type(::kvstore::v1::KeyOperationType value);
  private:
  ::kvstore::v1::KeyOperationType _internal_type() const;
  void _internal_set_type(::kvstore::v1::KeyOperationType value);
  public:

  // @@protoc_insertion_point(class_scope:kvstore.v1.Event)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::kvstore::v1::KeyValue* kv_;
  ::kvstore::v1::KeyValue* prev_kv_;
  int type_;
  friend struct ::TableStruct_kvstore_2fv1_2fkv_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// KVStoreWrapper

// uint64 account = 1 [json_name = "account"];
inline void KVStoreWrapper::clear_account() {
  account_ = uint64_t{0u};
}
inline uint64_t KVStoreWrapper::_internal_account() const {
  return account_;
}
inline uint64_t KVStoreWrapper::account() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KVStoreWrapper.account)
  return _internal_account();
}
inline void KVStoreWrapper::_internal_set_account(uint64_t value) {
  
  account_ = value;
}
inline void KVStoreWrapper::set_account(uint64_t value) {
  _internal_set_account(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.KVStoreWrapper.account)
}

// string bucket = 2 [json_name = "bucket"];
inline void KVStoreWrapper::clear_bucket() {
  bucket_.ClearToEmpty();
}
inline const std::string& KVStoreWrapper::bucket() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KVStoreWrapper.bucket)
  return _internal_bucket();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KVStoreWrapper::set_bucket(ArgT0&& arg0, ArgT... args) {
 
 bucket_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kvstore.v1.KVStoreWrapper.bucket)
}
inline std::string* KVStoreWrapper::mutable_bucket() {
  std::string* _s = _internal_mutable_bucket();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.KVStoreWrapper.bucket)
  return _s;
}
inline const std::string& KVStoreWrapper::_internal_bucket() const {
  return bucket_.Get();
}
inline void KVStoreWrapper::_internal_set_bucket(const std::string& value) {
  
  bucket_.Set(value, GetArenaForAllocation());
}
inline std::string* KVStoreWrapper::_internal_mutable_bucket() {
  
  return bucket_.Mutable(GetArenaForAllocation());
}
inline std::string* KVStoreWrapper::release_bucket() {
  // @@protoc_insertion_point(field_release:kvstore.v1.KVStoreWrapper.bucket)
  return bucket_.Release();
}
inline void KVStoreWrapper::set_allocated_bucket(std::string* bucket) {
  if (bucket != nullptr) {
    
  } else {
    
  }
  bucket_.SetAllocated(bucket, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bucket_.IsDefault()) {
    bucket_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.KVStoreWrapper.bucket)
}

// .kvstore.v1.KVStoreWrapper.RequestType typ = 3 [json_name = "typ"];
inline void KVStoreWrapper::clear_typ() {
  typ_ = 0;
}
inline ::kvstore::v1::KVStoreWrapper_RequestType KVStoreWrapper::_internal_typ() const {
  return static_cast< ::kvstore::v1::KVStoreWrapper_RequestType >(typ_);
}
inline ::kvstore::v1::KVStoreWrapper_RequestType KVStoreWrapper::typ() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KVStoreWrapper.typ)
  return _internal_typ();
}
inline void KVStoreWrapper::_internal_set_typ(::kvstore::v1::KVStoreWrapper_RequestType value) {
  
  typ_ = value;
}
inline void KVStoreWrapper::set_typ(::kvstore::v1::KVStoreWrapper_RequestType value) {
  _internal_set_typ(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.KVStoreWrapper.typ)
}

// .kvstore.v1.CreateAccountRequest create_account_request = 4 [json_name = "createAccountRequest"];
inline bool KVStoreWrapper::_internal_has_create_account_request() const {
  return payload_case() == kCreateAccountRequest;
}
inline bool KVStoreWrapper::has_create_account_request() const {
  return _internal_has_create_account_request();
}
inline void KVStoreWrapper::set_has_create_account_request() {
  _oneof_case_[0] = kCreateAccountRequest;
}
inline void KVStoreWrapper::clear_create_account_request() {
  if (_internal_has_create_account_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.create_account_request_;
    }
    clear_has_payload();
  }
}
inline ::kvstore::v1::CreateAccountRequest* KVStoreWrapper::release_create_account_request() {
  // @@protoc_insertion_point(field_release:kvstore.v1.KVStoreWrapper.create_account_request)
  if (_internal_has_create_account_request()) {
    clear_has_payload();
    ::kvstore::v1::CreateAccountRequest* temp = payload_.create_account_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.create_account_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kvstore::v1::CreateAccountRequest& KVStoreWrapper::_internal_create_account_request() const {
  return _internal_has_create_account_request()
      ? *payload_.create_account_request_
      : reinterpret_cast< ::kvstore::v1::CreateAccountRequest&>(::kvstore::v1::_CreateAccountRequest_default_instance_);
}
inline const ::kvstore::v1::CreateAccountRequest& KVStoreWrapper::create_account_request() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KVStoreWrapper.create_account_request)
  return _internal_create_account_request();
}
inline ::kvstore::v1::CreateAccountRequest* KVStoreWrapper::unsafe_arena_release_create_account_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kvstore.v1.KVStoreWrapper.create_account_request)
  if (_internal_has_create_account_request()) {
    clear_has_payload();
    ::kvstore::v1::CreateAccountRequest* temp = payload_.create_account_request_;
    payload_.create_account_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVStoreWrapper::unsafe_arena_set_allocated_create_account_request(::kvstore::v1::CreateAccountRequest* create_account_request) {
  clear_payload();
  if (create_account_request) {
    set_has_create_account_request();
    payload_.create_account_request_ = create_account_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.KVStoreWrapper.create_account_request)
}
inline ::kvstore::v1::CreateAccountRequest* KVStoreWrapper::_internal_mutable_create_account_request() {
  if (!_internal_has_create_account_request()) {
    clear_payload();
    set_has_create_account_request();
    payload_.create_account_request_ = CreateMaybeMessage< ::kvstore::v1::CreateAccountRequest >(GetArenaForAllocation());
  }
  return payload_.create_account_request_;
}
inline ::kvstore::v1::CreateAccountRequest* KVStoreWrapper::mutable_create_account_request() {
  ::kvstore::v1::CreateAccountRequest* _msg = _internal_mutable_create_account_request();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.KVStoreWrapper.create_account_request)
  return _msg;
}

// .kvstore.v1.CreateAccountResponse create_account_reply = 5 [json_name = "createAccountReply"];
inline bool KVStoreWrapper::_internal_has_create_account_reply() const {
  return payload_case() == kCreateAccountReply;
}
inline bool KVStoreWrapper::has_create_account_reply() const {
  return _internal_has_create_account_reply();
}
inline void KVStoreWrapper::set_has_create_account_reply() {
  _oneof_case_[0] = kCreateAccountReply;
}
inline void KVStoreWrapper::clear_create_account_reply() {
  if (_internal_has_create_account_reply()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.create_account_reply_;
    }
    clear_has_payload();
  }
}
inline ::kvstore::v1::CreateAccountResponse* KVStoreWrapper::release_create_account_reply() {
  // @@protoc_insertion_point(field_release:kvstore.v1.KVStoreWrapper.create_account_reply)
  if (_internal_has_create_account_reply()) {
    clear_has_payload();
    ::kvstore::v1::CreateAccountResponse* temp = payload_.create_account_reply_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.create_account_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kvstore::v1::CreateAccountResponse& KVStoreWrapper::_internal_create_account_reply() const {
  return _internal_has_create_account_reply()
      ? *payload_.create_account_reply_
      : reinterpret_cast< ::kvstore::v1::CreateAccountResponse&>(::kvstore::v1::_CreateAccountResponse_default_instance_);
}
inline const ::kvstore::v1::CreateAccountResponse& KVStoreWrapper::create_account_reply() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KVStoreWrapper.create_account_reply)
  return _internal_create_account_reply();
}
inline ::kvstore::v1::CreateAccountResponse* KVStoreWrapper::unsafe_arena_release_create_account_reply() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kvstore.v1.KVStoreWrapper.create_account_reply)
  if (_internal_has_create_account_reply()) {
    clear_has_payload();
    ::kvstore::v1::CreateAccountResponse* temp = payload_.create_account_reply_;
    payload_.create_account_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVStoreWrapper::unsafe_arena_set_allocated_create_account_reply(::kvstore::v1::CreateAccountResponse* create_account_reply) {
  clear_payload();
  if (create_account_reply) {
    set_has_create_account_reply();
    payload_.create_account_reply_ = create_account_reply;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.KVStoreWrapper.create_account_reply)
}
inline ::kvstore::v1::CreateAccountResponse* KVStoreWrapper::_internal_mutable_create_account_reply() {
  if (!_internal_has_create_account_reply()) {
    clear_payload();
    set_has_create_account_reply();
    payload_.create_account_reply_ = CreateMaybeMessage< ::kvstore::v1::CreateAccountResponse >(GetArenaForAllocation());
  }
  return payload_.create_account_reply_;
}
inline ::kvstore::v1::CreateAccountResponse* KVStoreWrapper::mutable_create_account_reply() {
  ::kvstore::v1::CreateAccountResponse* _msg = _internal_mutable_create_account_reply();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.KVStoreWrapper.create_account_reply)
  return _msg;
}

// .kvstore.v1.DeleteAccountRequest delete_account_request = 6 [json_name = "deleteAccountRequest"];
inline bool KVStoreWrapper::_internal_has_delete_account_request() const {
  return payload_case() == kDeleteAccountRequest;
}
inline bool KVStoreWrapper::has_delete_account_request() const {
  return _internal_has_delete_account_request();
}
inline void KVStoreWrapper::set_has_delete_account_request() {
  _oneof_case_[0] = kDeleteAccountRequest;
}
inline void KVStoreWrapper::clear_delete_account_request() {
  if (_internal_has_delete_account_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.delete_account_request_;
    }
    clear_has_payload();
  }
}
inline ::kvstore::v1::DeleteAccountRequest* KVStoreWrapper::release_delete_account_request() {
  // @@protoc_insertion_point(field_release:kvstore.v1.KVStoreWrapper.delete_account_request)
  if (_internal_has_delete_account_request()) {
    clear_has_payload();
    ::kvstore::v1::DeleteAccountRequest* temp = payload_.delete_account_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.delete_account_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kvstore::v1::DeleteAccountRequest& KVStoreWrapper::_internal_delete_account_request() const {
  return _internal_has_delete_account_request()
      ? *payload_.delete_account_request_
      : reinterpret_cast< ::kvstore::v1::DeleteAccountRequest&>(::kvstore::v1::_DeleteAccountRequest_default_instance_);
}
inline const ::kvstore::v1::DeleteAccountRequest& KVStoreWrapper::delete_account_request() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KVStoreWrapper.delete_account_request)
  return _internal_delete_account_request();
}
inline ::kvstore::v1::DeleteAccountRequest* KVStoreWrapper::unsafe_arena_release_delete_account_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kvstore.v1.KVStoreWrapper.delete_account_request)
  if (_internal_has_delete_account_request()) {
    clear_has_payload();
    ::kvstore::v1::DeleteAccountRequest* temp = payload_.delete_account_request_;
    payload_.delete_account_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVStoreWrapper::unsafe_arena_set_allocated_delete_account_request(::kvstore::v1::DeleteAccountRequest* delete_account_request) {
  clear_payload();
  if (delete_account_request) {
    set_has_delete_account_request();
    payload_.delete_account_request_ = delete_account_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.KVStoreWrapper.delete_account_request)
}
inline ::kvstore::v1::DeleteAccountRequest* KVStoreWrapper::_internal_mutable_delete_account_request() {
  if (!_internal_has_delete_account_request()) {
    clear_payload();
    set_has_delete_account_request();
    payload_.delete_account_request_ = CreateMaybeMessage< ::kvstore::v1::DeleteAccountRequest >(GetArenaForAllocation());
  }
  return payload_.delete_account_request_;
}
inline ::kvstore::v1::DeleteAccountRequest* KVStoreWrapper::mutable_delete_account_request() {
  ::kvstore::v1::DeleteAccountRequest* _msg = _internal_mutable_delete_account_request();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.KVStoreWrapper.delete_account_request)
  return _msg;
}

// .kvstore.v1.DeleteAccountResponse delete_account_reply = 7 [json_name = "deleteAccountReply"];
inline bool KVStoreWrapper::_internal_has_delete_account_reply() const {
  return payload_case() == kDeleteAccountReply;
}
inline bool KVStoreWrapper::has_delete_account_reply() const {
  return _internal_has_delete_account_reply();
}
inline void KVStoreWrapper::set_has_delete_account_reply() {
  _oneof_case_[0] = kDeleteAccountReply;
}
inline void KVStoreWrapper::clear_delete_account_reply() {
  if (_internal_has_delete_account_reply()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.delete_account_reply_;
    }
    clear_has_payload();
  }
}
inline ::kvstore::v1::DeleteAccountResponse* KVStoreWrapper::release_delete_account_reply() {
  // @@protoc_insertion_point(field_release:kvstore.v1.KVStoreWrapper.delete_account_reply)
  if (_internal_has_delete_account_reply()) {
    clear_has_payload();
    ::kvstore::v1::DeleteAccountResponse* temp = payload_.delete_account_reply_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.delete_account_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kvstore::v1::DeleteAccountResponse& KVStoreWrapper::_internal_delete_account_reply() const {
  return _internal_has_delete_account_reply()
      ? *payload_.delete_account_reply_
      : reinterpret_cast< ::kvstore::v1::DeleteAccountResponse&>(::kvstore::v1::_DeleteAccountResponse_default_instance_);
}
inline const ::kvstore::v1::DeleteAccountResponse& KVStoreWrapper::delete_account_reply() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KVStoreWrapper.delete_account_reply)
  return _internal_delete_account_reply();
}
inline ::kvstore::v1::DeleteAccountResponse* KVStoreWrapper::unsafe_arena_release_delete_account_reply() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kvstore.v1.KVStoreWrapper.delete_account_reply)
  if (_internal_has_delete_account_reply()) {
    clear_has_payload();
    ::kvstore::v1::DeleteAccountResponse* temp = payload_.delete_account_reply_;
    payload_.delete_account_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVStoreWrapper::unsafe_arena_set_allocated_delete_account_reply(::kvstore::v1::DeleteAccountResponse* delete_account_reply) {
  clear_payload();
  if (delete_account_reply) {
    set_has_delete_account_reply();
    payload_.delete_account_reply_ = delete_account_reply;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.KVStoreWrapper.delete_account_reply)
}
inline ::kvstore::v1::DeleteAccountResponse* KVStoreWrapper::_internal_mutable_delete_account_reply() {
  if (!_internal_has_delete_account_reply()) {
    clear_payload();
    set_has_delete_account_reply();
    payload_.delete_account_reply_ = CreateMaybeMessage< ::kvstore::v1::DeleteAccountResponse >(GetArenaForAllocation());
  }
  return payload_.delete_account_reply_;
}
inline ::kvstore::v1::DeleteAccountResponse* KVStoreWrapper::mutable_delete_account_reply() {
  ::kvstore::v1::DeleteAccountResponse* _msg = _internal_mutable_delete_account_reply();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.KVStoreWrapper.delete_account_reply)
  return _msg;
}

// .kvstore.v1.GetAccountDescriptorRequest get_account_descriptor_request = 8 [json_name = "getAccountDescriptorRequest"];
inline bool KVStoreWrapper::_internal_has_get_account_descriptor_request() const {
  return payload_case() == kGetAccountDescriptorRequest;
}
inline bool KVStoreWrapper::has_get_account_descriptor_request() const {
  return _internal_has_get_account_descriptor_request();
}
inline void KVStoreWrapper::set_has_get_account_descriptor_request() {
  _oneof_case_[0] = kGetAccountDescriptorRequest;
}
inline void KVStoreWrapper::clear_get_account_descriptor_request() {
  if (_internal_has_get_account_descriptor_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.get_account_descriptor_request_;
    }
    clear_has_payload();
  }
}
inline ::kvstore::v1::GetAccountDescriptorRequest* KVStoreWrapper::release_get_account_descriptor_request() {
  // @@protoc_insertion_point(field_release:kvstore.v1.KVStoreWrapper.get_account_descriptor_request)
  if (_internal_has_get_account_descriptor_request()) {
    clear_has_payload();
    ::kvstore::v1::GetAccountDescriptorRequest* temp = payload_.get_account_descriptor_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.get_account_descriptor_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kvstore::v1::GetAccountDescriptorRequest& KVStoreWrapper::_internal_get_account_descriptor_request() const {
  return _internal_has_get_account_descriptor_request()
      ? *payload_.get_account_descriptor_request_
      : reinterpret_cast< ::kvstore::v1::GetAccountDescriptorRequest&>(::kvstore::v1::_GetAccountDescriptorRequest_default_instance_);
}
inline const ::kvstore::v1::GetAccountDescriptorRequest& KVStoreWrapper::get_account_descriptor_request() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KVStoreWrapper.get_account_descriptor_request)
  return _internal_get_account_descriptor_request();
}
inline ::kvstore::v1::GetAccountDescriptorRequest* KVStoreWrapper::unsafe_arena_release_get_account_descriptor_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kvstore.v1.KVStoreWrapper.get_account_descriptor_request)
  if (_internal_has_get_account_descriptor_request()) {
    clear_has_payload();
    ::kvstore::v1::GetAccountDescriptorRequest* temp = payload_.get_account_descriptor_request_;
    payload_.get_account_descriptor_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVStoreWrapper::unsafe_arena_set_allocated_get_account_descriptor_request(::kvstore::v1::GetAccountDescriptorRequest* get_account_descriptor_request) {
  clear_payload();
  if (get_account_descriptor_request) {
    set_has_get_account_descriptor_request();
    payload_.get_account_descriptor_request_ = get_account_descriptor_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.KVStoreWrapper.get_account_descriptor_request)
}
inline ::kvstore::v1::GetAccountDescriptorRequest* KVStoreWrapper::_internal_mutable_get_account_descriptor_request() {
  if (!_internal_has_get_account_descriptor_request()) {
    clear_payload();
    set_has_get_account_descriptor_request();
    payload_.get_account_descriptor_request_ = CreateMaybeMessage< ::kvstore::v1::GetAccountDescriptorRequest >(GetArenaForAllocation());
  }
  return payload_.get_account_descriptor_request_;
}
inline ::kvstore::v1::GetAccountDescriptorRequest* KVStoreWrapper::mutable_get_account_descriptor_request() {
  ::kvstore::v1::GetAccountDescriptorRequest* _msg = _internal_mutable_get_account_descriptor_request();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.KVStoreWrapper.get_account_descriptor_request)
  return _msg;
}

// .kvstore.v1.GetAccountDescriptorResponse get_account_descriptor_reply = 9 [json_name = "getAccountDescriptorReply"];
inline bool KVStoreWrapper::_internal_has_get_account_descriptor_reply() const {
  return payload_case() == kGetAccountDescriptorReply;
}
inline bool KVStoreWrapper::has_get_account_descriptor_reply() const {
  return _internal_has_get_account_descriptor_reply();
}
inline void KVStoreWrapper::set_has_get_account_descriptor_reply() {
  _oneof_case_[0] = kGetAccountDescriptorReply;
}
inline void KVStoreWrapper::clear_get_account_descriptor_reply() {
  if (_internal_has_get_account_descriptor_reply()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.get_account_descriptor_reply_;
    }
    clear_has_payload();
  }
}
inline ::kvstore::v1::GetAccountDescriptorResponse* KVStoreWrapper::release_get_account_descriptor_reply() {
  // @@protoc_insertion_point(field_release:kvstore.v1.KVStoreWrapper.get_account_descriptor_reply)
  if (_internal_has_get_account_descriptor_reply()) {
    clear_has_payload();
    ::kvstore::v1::GetAccountDescriptorResponse* temp = payload_.get_account_descriptor_reply_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.get_account_descriptor_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kvstore::v1::GetAccountDescriptorResponse& KVStoreWrapper::_internal_get_account_descriptor_reply() const {
  return _internal_has_get_account_descriptor_reply()
      ? *payload_.get_account_descriptor_reply_
      : reinterpret_cast< ::kvstore::v1::GetAccountDescriptorResponse&>(::kvstore::v1::_GetAccountDescriptorResponse_default_instance_);
}
inline const ::kvstore::v1::GetAccountDescriptorResponse& KVStoreWrapper::get_account_descriptor_reply() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KVStoreWrapper.get_account_descriptor_reply)
  return _internal_get_account_descriptor_reply();
}
inline ::kvstore::v1::GetAccountDescriptorResponse* KVStoreWrapper::unsafe_arena_release_get_account_descriptor_reply() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kvstore.v1.KVStoreWrapper.get_account_descriptor_reply)
  if (_internal_has_get_account_descriptor_reply()) {
    clear_has_payload();
    ::kvstore::v1::GetAccountDescriptorResponse* temp = payload_.get_account_descriptor_reply_;
    payload_.get_account_descriptor_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVStoreWrapper::unsafe_arena_set_allocated_get_account_descriptor_reply(::kvstore::v1::GetAccountDescriptorResponse* get_account_descriptor_reply) {
  clear_payload();
  if (get_account_descriptor_reply) {
    set_has_get_account_descriptor_reply();
    payload_.get_account_descriptor_reply_ = get_account_descriptor_reply;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.KVStoreWrapper.get_account_descriptor_reply)
}
inline ::kvstore::v1::GetAccountDescriptorResponse* KVStoreWrapper::_internal_mutable_get_account_descriptor_reply() {
  if (!_internal_has_get_account_descriptor_reply()) {
    clear_payload();
    set_has_get_account_descriptor_reply();
    payload_.get_account_descriptor_reply_ = CreateMaybeMessage< ::kvstore::v1::GetAccountDescriptorResponse >(GetArenaForAllocation());
  }
  return payload_.get_account_descriptor_reply_;
}
inline ::kvstore::v1::GetAccountDescriptorResponse* KVStoreWrapper::mutable_get_account_descriptor_reply() {
  ::kvstore::v1::GetAccountDescriptorResponse* _msg = _internal_mutable_get_account_descriptor_reply();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.KVStoreWrapper.get_account_descriptor_reply)
  return _msg;
}

// .kvstore.v1.CreateBucketRequest create_bucket_request = 10 [json_name = "createBucketRequest"];
inline bool KVStoreWrapper::_internal_has_create_bucket_request() const {
  return payload_case() == kCreateBucketRequest;
}
inline bool KVStoreWrapper::has_create_bucket_request() const {
  return _internal_has_create_bucket_request();
}
inline void KVStoreWrapper::set_has_create_bucket_request() {
  _oneof_case_[0] = kCreateBucketRequest;
}
inline void KVStoreWrapper::clear_create_bucket_request() {
  if (_internal_has_create_bucket_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.create_bucket_request_;
    }
    clear_has_payload();
  }
}
inline ::kvstore::v1::CreateBucketRequest* KVStoreWrapper::release_create_bucket_request() {
  // @@protoc_insertion_point(field_release:kvstore.v1.KVStoreWrapper.create_bucket_request)
  if (_internal_has_create_bucket_request()) {
    clear_has_payload();
    ::kvstore::v1::CreateBucketRequest* temp = payload_.create_bucket_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.create_bucket_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kvstore::v1::CreateBucketRequest& KVStoreWrapper::_internal_create_bucket_request() const {
  return _internal_has_create_bucket_request()
      ? *payload_.create_bucket_request_
      : reinterpret_cast< ::kvstore::v1::CreateBucketRequest&>(::kvstore::v1::_CreateBucketRequest_default_instance_);
}
inline const ::kvstore::v1::CreateBucketRequest& KVStoreWrapper::create_bucket_request() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KVStoreWrapper.create_bucket_request)
  return _internal_create_bucket_request();
}
inline ::kvstore::v1::CreateBucketRequest* KVStoreWrapper::unsafe_arena_release_create_bucket_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kvstore.v1.KVStoreWrapper.create_bucket_request)
  if (_internal_has_create_bucket_request()) {
    clear_has_payload();
    ::kvstore::v1::CreateBucketRequest* temp = payload_.create_bucket_request_;
    payload_.create_bucket_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVStoreWrapper::unsafe_arena_set_allocated_create_bucket_request(::kvstore::v1::CreateBucketRequest* create_bucket_request) {
  clear_payload();
  if (create_bucket_request) {
    set_has_create_bucket_request();
    payload_.create_bucket_request_ = create_bucket_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.KVStoreWrapper.create_bucket_request)
}
inline ::kvstore::v1::CreateBucketRequest* KVStoreWrapper::_internal_mutable_create_bucket_request() {
  if (!_internal_has_create_bucket_request()) {
    clear_payload();
    set_has_create_bucket_request();
    payload_.create_bucket_request_ = CreateMaybeMessage< ::kvstore::v1::CreateBucketRequest >(GetArenaForAllocation());
  }
  return payload_.create_bucket_request_;
}
inline ::kvstore::v1::CreateBucketRequest* KVStoreWrapper::mutable_create_bucket_request() {
  ::kvstore::v1::CreateBucketRequest* _msg = _internal_mutable_create_bucket_request();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.KVStoreWrapper.create_bucket_request)
  return _msg;
}

// .kvstore.v1.CreateBucketResponse create_bucket_reply = 11 [json_name = "createBucketReply"];
inline bool KVStoreWrapper::_internal_has_create_bucket_reply() const {
  return payload_case() == kCreateBucketReply;
}
inline bool KVStoreWrapper::has_create_bucket_reply() const {
  return _internal_has_create_bucket_reply();
}
inline void KVStoreWrapper::set_has_create_bucket_reply() {
  _oneof_case_[0] = kCreateBucketReply;
}
inline void KVStoreWrapper::clear_create_bucket_reply() {
  if (_internal_has_create_bucket_reply()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.create_bucket_reply_;
    }
    clear_has_payload();
  }
}
inline ::kvstore::v1::CreateBucketResponse* KVStoreWrapper::release_create_bucket_reply() {
  // @@protoc_insertion_point(field_release:kvstore.v1.KVStoreWrapper.create_bucket_reply)
  if (_internal_has_create_bucket_reply()) {
    clear_has_payload();
    ::kvstore::v1::CreateBucketResponse* temp = payload_.create_bucket_reply_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.create_bucket_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kvstore::v1::CreateBucketResponse& KVStoreWrapper::_internal_create_bucket_reply() const {
  return _internal_has_create_bucket_reply()
      ? *payload_.create_bucket_reply_
      : reinterpret_cast< ::kvstore::v1::CreateBucketResponse&>(::kvstore::v1::_CreateBucketResponse_default_instance_);
}
inline const ::kvstore::v1::CreateBucketResponse& KVStoreWrapper::create_bucket_reply() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KVStoreWrapper.create_bucket_reply)
  return _internal_create_bucket_reply();
}
inline ::kvstore::v1::CreateBucketResponse* KVStoreWrapper::unsafe_arena_release_create_bucket_reply() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kvstore.v1.KVStoreWrapper.create_bucket_reply)
  if (_internal_has_create_bucket_reply()) {
    clear_has_payload();
    ::kvstore::v1::CreateBucketResponse* temp = payload_.create_bucket_reply_;
    payload_.create_bucket_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVStoreWrapper::unsafe_arena_set_allocated_create_bucket_reply(::kvstore::v1::CreateBucketResponse* create_bucket_reply) {
  clear_payload();
  if (create_bucket_reply) {
    set_has_create_bucket_reply();
    payload_.create_bucket_reply_ = create_bucket_reply;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.KVStoreWrapper.create_bucket_reply)
}
inline ::kvstore::v1::CreateBucketResponse* KVStoreWrapper::_internal_mutable_create_bucket_reply() {
  if (!_internal_has_create_bucket_reply()) {
    clear_payload();
    set_has_create_bucket_reply();
    payload_.create_bucket_reply_ = CreateMaybeMessage< ::kvstore::v1::CreateBucketResponse >(GetArenaForAllocation());
  }
  return payload_.create_bucket_reply_;
}
inline ::kvstore::v1::CreateBucketResponse* KVStoreWrapper::mutable_create_bucket_reply() {
  ::kvstore::v1::CreateBucketResponse* _msg = _internal_mutable_create_bucket_reply();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.KVStoreWrapper.create_bucket_reply)
  return _msg;
}

// .kvstore.v1.DeleteBucketRequest delete_bucket_request = 12 [json_name = "deleteBucketRequest"];
inline bool KVStoreWrapper::_internal_has_delete_bucket_request() const {
  return payload_case() == kDeleteBucketRequest;
}
inline bool KVStoreWrapper::has_delete_bucket_request() const {
  return _internal_has_delete_bucket_request();
}
inline void KVStoreWrapper::set_has_delete_bucket_request() {
  _oneof_case_[0] = kDeleteBucketRequest;
}
inline void KVStoreWrapper::clear_delete_bucket_request() {
  if (_internal_has_delete_bucket_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.delete_bucket_request_;
    }
    clear_has_payload();
  }
}
inline ::kvstore::v1::DeleteBucketRequest* KVStoreWrapper::release_delete_bucket_request() {
  // @@protoc_insertion_point(field_release:kvstore.v1.KVStoreWrapper.delete_bucket_request)
  if (_internal_has_delete_bucket_request()) {
    clear_has_payload();
    ::kvstore::v1::DeleteBucketRequest* temp = payload_.delete_bucket_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.delete_bucket_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kvstore::v1::DeleteBucketRequest& KVStoreWrapper::_internal_delete_bucket_request() const {
  return _internal_has_delete_bucket_request()
      ? *payload_.delete_bucket_request_
      : reinterpret_cast< ::kvstore::v1::DeleteBucketRequest&>(::kvstore::v1::_DeleteBucketRequest_default_instance_);
}
inline const ::kvstore::v1::DeleteBucketRequest& KVStoreWrapper::delete_bucket_request() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KVStoreWrapper.delete_bucket_request)
  return _internal_delete_bucket_request();
}
inline ::kvstore::v1::DeleteBucketRequest* KVStoreWrapper::unsafe_arena_release_delete_bucket_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kvstore.v1.KVStoreWrapper.delete_bucket_request)
  if (_internal_has_delete_bucket_request()) {
    clear_has_payload();
    ::kvstore::v1::DeleteBucketRequest* temp = payload_.delete_bucket_request_;
    payload_.delete_bucket_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVStoreWrapper::unsafe_arena_set_allocated_delete_bucket_request(::kvstore::v1::DeleteBucketRequest* delete_bucket_request) {
  clear_payload();
  if (delete_bucket_request) {
    set_has_delete_bucket_request();
    payload_.delete_bucket_request_ = delete_bucket_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.KVStoreWrapper.delete_bucket_request)
}
inline ::kvstore::v1::DeleteBucketRequest* KVStoreWrapper::_internal_mutable_delete_bucket_request() {
  if (!_internal_has_delete_bucket_request()) {
    clear_payload();
    set_has_delete_bucket_request();
    payload_.delete_bucket_request_ = CreateMaybeMessage< ::kvstore::v1::DeleteBucketRequest >(GetArenaForAllocation());
  }
  return payload_.delete_bucket_request_;
}
inline ::kvstore::v1::DeleteBucketRequest* KVStoreWrapper::mutable_delete_bucket_request() {
  ::kvstore::v1::DeleteBucketRequest* _msg = _internal_mutable_delete_bucket_request();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.KVStoreWrapper.delete_bucket_request)
  return _msg;
}

// .kvstore.v1.DeleteBucketResponse delete_bucket_reply = 13 [json_name = "deleteBucketReply"];
inline bool KVStoreWrapper::_internal_has_delete_bucket_reply() const {
  return payload_case() == kDeleteBucketReply;
}
inline bool KVStoreWrapper::has_delete_bucket_reply() const {
  return _internal_has_delete_bucket_reply();
}
inline void KVStoreWrapper::set_has_delete_bucket_reply() {
  _oneof_case_[0] = kDeleteBucketReply;
}
inline void KVStoreWrapper::clear_delete_bucket_reply() {
  if (_internal_has_delete_bucket_reply()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.delete_bucket_reply_;
    }
    clear_has_payload();
  }
}
inline ::kvstore::v1::DeleteBucketResponse* KVStoreWrapper::release_delete_bucket_reply() {
  // @@protoc_insertion_point(field_release:kvstore.v1.KVStoreWrapper.delete_bucket_reply)
  if (_internal_has_delete_bucket_reply()) {
    clear_has_payload();
    ::kvstore::v1::DeleteBucketResponse* temp = payload_.delete_bucket_reply_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.delete_bucket_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kvstore::v1::DeleteBucketResponse& KVStoreWrapper::_internal_delete_bucket_reply() const {
  return _internal_has_delete_bucket_reply()
      ? *payload_.delete_bucket_reply_
      : reinterpret_cast< ::kvstore::v1::DeleteBucketResponse&>(::kvstore::v1::_DeleteBucketResponse_default_instance_);
}
inline const ::kvstore::v1::DeleteBucketResponse& KVStoreWrapper::delete_bucket_reply() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KVStoreWrapper.delete_bucket_reply)
  return _internal_delete_bucket_reply();
}
inline ::kvstore::v1::DeleteBucketResponse* KVStoreWrapper::unsafe_arena_release_delete_bucket_reply() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kvstore.v1.KVStoreWrapper.delete_bucket_reply)
  if (_internal_has_delete_bucket_reply()) {
    clear_has_payload();
    ::kvstore::v1::DeleteBucketResponse* temp = payload_.delete_bucket_reply_;
    payload_.delete_bucket_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVStoreWrapper::unsafe_arena_set_allocated_delete_bucket_reply(::kvstore::v1::DeleteBucketResponse* delete_bucket_reply) {
  clear_payload();
  if (delete_bucket_reply) {
    set_has_delete_bucket_reply();
    payload_.delete_bucket_reply_ = delete_bucket_reply;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.KVStoreWrapper.delete_bucket_reply)
}
inline ::kvstore::v1::DeleteBucketResponse* KVStoreWrapper::_internal_mutable_delete_bucket_reply() {
  if (!_internal_has_delete_bucket_reply()) {
    clear_payload();
    set_has_delete_bucket_reply();
    payload_.delete_bucket_reply_ = CreateMaybeMessage< ::kvstore::v1::DeleteBucketResponse >(GetArenaForAllocation());
  }
  return payload_.delete_bucket_reply_;
}
inline ::kvstore::v1::DeleteBucketResponse* KVStoreWrapper::mutable_delete_bucket_reply() {
  ::kvstore::v1::DeleteBucketResponse* _msg = _internal_mutable_delete_bucket_reply();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.KVStoreWrapper.delete_bucket_reply)
  return _msg;
}

// .kvstore.v1.GetKeyRequest get_key_request = 14 [json_name = "getKeyRequest"];
inline bool KVStoreWrapper::_internal_has_get_key_request() const {
  return payload_case() == kGetKeyRequest;
}
inline bool KVStoreWrapper::has_get_key_request() const {
  return _internal_has_get_key_request();
}
inline void KVStoreWrapper::set_has_get_key_request() {
  _oneof_case_[0] = kGetKeyRequest;
}
inline void KVStoreWrapper::clear_get_key_request() {
  if (_internal_has_get_key_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.get_key_request_;
    }
    clear_has_payload();
  }
}
inline ::kvstore::v1::GetKeyRequest* KVStoreWrapper::release_get_key_request() {
  // @@protoc_insertion_point(field_release:kvstore.v1.KVStoreWrapper.get_key_request)
  if (_internal_has_get_key_request()) {
    clear_has_payload();
    ::kvstore::v1::GetKeyRequest* temp = payload_.get_key_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.get_key_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kvstore::v1::GetKeyRequest& KVStoreWrapper::_internal_get_key_request() const {
  return _internal_has_get_key_request()
      ? *payload_.get_key_request_
      : reinterpret_cast< ::kvstore::v1::GetKeyRequest&>(::kvstore::v1::_GetKeyRequest_default_instance_);
}
inline const ::kvstore::v1::GetKeyRequest& KVStoreWrapper::get_key_request() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KVStoreWrapper.get_key_request)
  return _internal_get_key_request();
}
inline ::kvstore::v1::GetKeyRequest* KVStoreWrapper::unsafe_arena_release_get_key_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kvstore.v1.KVStoreWrapper.get_key_request)
  if (_internal_has_get_key_request()) {
    clear_has_payload();
    ::kvstore::v1::GetKeyRequest* temp = payload_.get_key_request_;
    payload_.get_key_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVStoreWrapper::unsafe_arena_set_allocated_get_key_request(::kvstore::v1::GetKeyRequest* get_key_request) {
  clear_payload();
  if (get_key_request) {
    set_has_get_key_request();
    payload_.get_key_request_ = get_key_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.KVStoreWrapper.get_key_request)
}
inline ::kvstore::v1::GetKeyRequest* KVStoreWrapper::_internal_mutable_get_key_request() {
  if (!_internal_has_get_key_request()) {
    clear_payload();
    set_has_get_key_request();
    payload_.get_key_request_ = CreateMaybeMessage< ::kvstore::v1::GetKeyRequest >(GetArenaForAllocation());
  }
  return payload_.get_key_request_;
}
inline ::kvstore::v1::GetKeyRequest* KVStoreWrapper::mutable_get_key_request() {
  ::kvstore::v1::GetKeyRequest* _msg = _internal_mutable_get_key_request();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.KVStoreWrapper.get_key_request)
  return _msg;
}

// .kvstore.v1.GetKeyResponse get_key_reply = 15 [json_name = "getKeyReply"];
inline bool KVStoreWrapper::_internal_has_get_key_reply() const {
  return payload_case() == kGetKeyReply;
}
inline bool KVStoreWrapper::has_get_key_reply() const {
  return _internal_has_get_key_reply();
}
inline void KVStoreWrapper::set_has_get_key_reply() {
  _oneof_case_[0] = kGetKeyReply;
}
inline void KVStoreWrapper::clear_get_key_reply() {
  if (_internal_has_get_key_reply()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.get_key_reply_;
    }
    clear_has_payload();
  }
}
inline ::kvstore::v1::GetKeyResponse* KVStoreWrapper::release_get_key_reply() {
  // @@protoc_insertion_point(field_release:kvstore.v1.KVStoreWrapper.get_key_reply)
  if (_internal_has_get_key_reply()) {
    clear_has_payload();
    ::kvstore::v1::GetKeyResponse* temp = payload_.get_key_reply_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.get_key_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kvstore::v1::GetKeyResponse& KVStoreWrapper::_internal_get_key_reply() const {
  return _internal_has_get_key_reply()
      ? *payload_.get_key_reply_
      : reinterpret_cast< ::kvstore::v1::GetKeyResponse&>(::kvstore::v1::_GetKeyResponse_default_instance_);
}
inline const ::kvstore::v1::GetKeyResponse& KVStoreWrapper::get_key_reply() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KVStoreWrapper.get_key_reply)
  return _internal_get_key_reply();
}
inline ::kvstore::v1::GetKeyResponse* KVStoreWrapper::unsafe_arena_release_get_key_reply() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kvstore.v1.KVStoreWrapper.get_key_reply)
  if (_internal_has_get_key_reply()) {
    clear_has_payload();
    ::kvstore::v1::GetKeyResponse* temp = payload_.get_key_reply_;
    payload_.get_key_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVStoreWrapper::unsafe_arena_set_allocated_get_key_reply(::kvstore::v1::GetKeyResponse* get_key_reply) {
  clear_payload();
  if (get_key_reply) {
    set_has_get_key_reply();
    payload_.get_key_reply_ = get_key_reply;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.KVStoreWrapper.get_key_reply)
}
inline ::kvstore::v1::GetKeyResponse* KVStoreWrapper::_internal_mutable_get_key_reply() {
  if (!_internal_has_get_key_reply()) {
    clear_payload();
    set_has_get_key_reply();
    payload_.get_key_reply_ = CreateMaybeMessage< ::kvstore::v1::GetKeyResponse >(GetArenaForAllocation());
  }
  return payload_.get_key_reply_;
}
inline ::kvstore::v1::GetKeyResponse* KVStoreWrapper::mutable_get_key_reply() {
  ::kvstore::v1::GetKeyResponse* _msg = _internal_mutable_get_key_reply();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.KVStoreWrapper.get_key_reply)
  return _msg;
}

// .kvstore.v1.PutKeyRequest put_key_request = 16 [json_name = "putKeyRequest"];
inline bool KVStoreWrapper::_internal_has_put_key_request() const {
  return payload_case() == kPutKeyRequest;
}
inline bool KVStoreWrapper::has_put_key_request() const {
  return _internal_has_put_key_request();
}
inline void KVStoreWrapper::set_has_put_key_request() {
  _oneof_case_[0] = kPutKeyRequest;
}
inline void KVStoreWrapper::clear_put_key_request() {
  if (_internal_has_put_key_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.put_key_request_;
    }
    clear_has_payload();
  }
}
inline ::kvstore::v1::PutKeyRequest* KVStoreWrapper::release_put_key_request() {
  // @@protoc_insertion_point(field_release:kvstore.v1.KVStoreWrapper.put_key_request)
  if (_internal_has_put_key_request()) {
    clear_has_payload();
    ::kvstore::v1::PutKeyRequest* temp = payload_.put_key_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.put_key_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kvstore::v1::PutKeyRequest& KVStoreWrapper::_internal_put_key_request() const {
  return _internal_has_put_key_request()
      ? *payload_.put_key_request_
      : reinterpret_cast< ::kvstore::v1::PutKeyRequest&>(::kvstore::v1::_PutKeyRequest_default_instance_);
}
inline const ::kvstore::v1::PutKeyRequest& KVStoreWrapper::put_key_request() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KVStoreWrapper.put_key_request)
  return _internal_put_key_request();
}
inline ::kvstore::v1::PutKeyRequest* KVStoreWrapper::unsafe_arena_release_put_key_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kvstore.v1.KVStoreWrapper.put_key_request)
  if (_internal_has_put_key_request()) {
    clear_has_payload();
    ::kvstore::v1::PutKeyRequest* temp = payload_.put_key_request_;
    payload_.put_key_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVStoreWrapper::unsafe_arena_set_allocated_put_key_request(::kvstore::v1::PutKeyRequest* put_key_request) {
  clear_payload();
  if (put_key_request) {
    set_has_put_key_request();
    payload_.put_key_request_ = put_key_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.KVStoreWrapper.put_key_request)
}
inline ::kvstore::v1::PutKeyRequest* KVStoreWrapper::_internal_mutable_put_key_request() {
  if (!_internal_has_put_key_request()) {
    clear_payload();
    set_has_put_key_request();
    payload_.put_key_request_ = CreateMaybeMessage< ::kvstore::v1::PutKeyRequest >(GetArenaForAllocation());
  }
  return payload_.put_key_request_;
}
inline ::kvstore::v1::PutKeyRequest* KVStoreWrapper::mutable_put_key_request() {
  ::kvstore::v1::PutKeyRequest* _msg = _internal_mutable_put_key_request();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.KVStoreWrapper.put_key_request)
  return _msg;
}

// .kvstore.v1.PutKeyResponse put_key_reply = 17 [json_name = "putKeyReply"];
inline bool KVStoreWrapper::_internal_has_put_key_reply() const {
  return payload_case() == kPutKeyReply;
}
inline bool KVStoreWrapper::has_put_key_reply() const {
  return _internal_has_put_key_reply();
}
inline void KVStoreWrapper::set_has_put_key_reply() {
  _oneof_case_[0] = kPutKeyReply;
}
inline void KVStoreWrapper::clear_put_key_reply() {
  if (_internal_has_put_key_reply()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.put_key_reply_;
    }
    clear_has_payload();
  }
}
inline ::kvstore::v1::PutKeyResponse* KVStoreWrapper::release_put_key_reply() {
  // @@protoc_insertion_point(field_release:kvstore.v1.KVStoreWrapper.put_key_reply)
  if (_internal_has_put_key_reply()) {
    clear_has_payload();
    ::kvstore::v1::PutKeyResponse* temp = payload_.put_key_reply_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.put_key_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kvstore::v1::PutKeyResponse& KVStoreWrapper::_internal_put_key_reply() const {
  return _internal_has_put_key_reply()
      ? *payload_.put_key_reply_
      : reinterpret_cast< ::kvstore::v1::PutKeyResponse&>(::kvstore::v1::_PutKeyResponse_default_instance_);
}
inline const ::kvstore::v1::PutKeyResponse& KVStoreWrapper::put_key_reply() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KVStoreWrapper.put_key_reply)
  return _internal_put_key_reply();
}
inline ::kvstore::v1::PutKeyResponse* KVStoreWrapper::unsafe_arena_release_put_key_reply() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kvstore.v1.KVStoreWrapper.put_key_reply)
  if (_internal_has_put_key_reply()) {
    clear_has_payload();
    ::kvstore::v1::PutKeyResponse* temp = payload_.put_key_reply_;
    payload_.put_key_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVStoreWrapper::unsafe_arena_set_allocated_put_key_reply(::kvstore::v1::PutKeyResponse* put_key_reply) {
  clear_payload();
  if (put_key_reply) {
    set_has_put_key_reply();
    payload_.put_key_reply_ = put_key_reply;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.KVStoreWrapper.put_key_reply)
}
inline ::kvstore::v1::PutKeyResponse* KVStoreWrapper::_internal_mutable_put_key_reply() {
  if (!_internal_has_put_key_reply()) {
    clear_payload();
    set_has_put_key_reply();
    payload_.put_key_reply_ = CreateMaybeMessage< ::kvstore::v1::PutKeyResponse >(GetArenaForAllocation());
  }
  return payload_.put_key_reply_;
}
inline ::kvstore::v1::PutKeyResponse* KVStoreWrapper::mutable_put_key_reply() {
  ::kvstore::v1::PutKeyResponse* _msg = _internal_mutable_put_key_reply();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.KVStoreWrapper.put_key_reply)
  return _msg;
}

// .kvstore.v1.DeleteKeyRequest delete_key_request = 18 [json_name = "deleteKeyRequest"];
inline bool KVStoreWrapper::_internal_has_delete_key_request() const {
  return payload_case() == kDeleteKeyRequest;
}
inline bool KVStoreWrapper::has_delete_key_request() const {
  return _internal_has_delete_key_request();
}
inline void KVStoreWrapper::set_has_delete_key_request() {
  _oneof_case_[0] = kDeleteKeyRequest;
}
inline void KVStoreWrapper::clear_delete_key_request() {
  if (_internal_has_delete_key_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.delete_key_request_;
    }
    clear_has_payload();
  }
}
inline ::kvstore::v1::DeleteKeyRequest* KVStoreWrapper::release_delete_key_request() {
  // @@protoc_insertion_point(field_release:kvstore.v1.KVStoreWrapper.delete_key_request)
  if (_internal_has_delete_key_request()) {
    clear_has_payload();
    ::kvstore::v1::DeleteKeyRequest* temp = payload_.delete_key_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.delete_key_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kvstore::v1::DeleteKeyRequest& KVStoreWrapper::_internal_delete_key_request() const {
  return _internal_has_delete_key_request()
      ? *payload_.delete_key_request_
      : reinterpret_cast< ::kvstore::v1::DeleteKeyRequest&>(::kvstore::v1::_DeleteKeyRequest_default_instance_);
}
inline const ::kvstore::v1::DeleteKeyRequest& KVStoreWrapper::delete_key_request() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KVStoreWrapper.delete_key_request)
  return _internal_delete_key_request();
}
inline ::kvstore::v1::DeleteKeyRequest* KVStoreWrapper::unsafe_arena_release_delete_key_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kvstore.v1.KVStoreWrapper.delete_key_request)
  if (_internal_has_delete_key_request()) {
    clear_has_payload();
    ::kvstore::v1::DeleteKeyRequest* temp = payload_.delete_key_request_;
    payload_.delete_key_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVStoreWrapper::unsafe_arena_set_allocated_delete_key_request(::kvstore::v1::DeleteKeyRequest* delete_key_request) {
  clear_payload();
  if (delete_key_request) {
    set_has_delete_key_request();
    payload_.delete_key_request_ = delete_key_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.KVStoreWrapper.delete_key_request)
}
inline ::kvstore::v1::DeleteKeyRequest* KVStoreWrapper::_internal_mutable_delete_key_request() {
  if (!_internal_has_delete_key_request()) {
    clear_payload();
    set_has_delete_key_request();
    payload_.delete_key_request_ = CreateMaybeMessage< ::kvstore::v1::DeleteKeyRequest >(GetArenaForAllocation());
  }
  return payload_.delete_key_request_;
}
inline ::kvstore::v1::DeleteKeyRequest* KVStoreWrapper::mutable_delete_key_request() {
  ::kvstore::v1::DeleteKeyRequest* _msg = _internal_mutable_delete_key_request();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.KVStoreWrapper.delete_key_request)
  return _msg;
}

// .kvstore.v1.DeleteKeyResponse delete_key_reply = 19 [json_name = "deleteKeyReply"];
inline bool KVStoreWrapper::_internal_has_delete_key_reply() const {
  return payload_case() == kDeleteKeyReply;
}
inline bool KVStoreWrapper::has_delete_key_reply() const {
  return _internal_has_delete_key_reply();
}
inline void KVStoreWrapper::set_has_delete_key_reply() {
  _oneof_case_[0] = kDeleteKeyReply;
}
inline void KVStoreWrapper::clear_delete_key_reply() {
  if (_internal_has_delete_key_reply()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.delete_key_reply_;
    }
    clear_has_payload();
  }
}
inline ::kvstore::v1::DeleteKeyResponse* KVStoreWrapper::release_delete_key_reply() {
  // @@protoc_insertion_point(field_release:kvstore.v1.KVStoreWrapper.delete_key_reply)
  if (_internal_has_delete_key_reply()) {
    clear_has_payload();
    ::kvstore::v1::DeleteKeyResponse* temp = payload_.delete_key_reply_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.delete_key_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kvstore::v1::DeleteKeyResponse& KVStoreWrapper::_internal_delete_key_reply() const {
  return _internal_has_delete_key_reply()
      ? *payload_.delete_key_reply_
      : reinterpret_cast< ::kvstore::v1::DeleteKeyResponse&>(::kvstore::v1::_DeleteKeyResponse_default_instance_);
}
inline const ::kvstore::v1::DeleteKeyResponse& KVStoreWrapper::delete_key_reply() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KVStoreWrapper.delete_key_reply)
  return _internal_delete_key_reply();
}
inline ::kvstore::v1::DeleteKeyResponse* KVStoreWrapper::unsafe_arena_release_delete_key_reply() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kvstore.v1.KVStoreWrapper.delete_key_reply)
  if (_internal_has_delete_key_reply()) {
    clear_has_payload();
    ::kvstore::v1::DeleteKeyResponse* temp = payload_.delete_key_reply_;
    payload_.delete_key_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVStoreWrapper::unsafe_arena_set_allocated_delete_key_reply(::kvstore::v1::DeleteKeyResponse* delete_key_reply) {
  clear_payload();
  if (delete_key_reply) {
    set_has_delete_key_reply();
    payload_.delete_key_reply_ = delete_key_reply;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.KVStoreWrapper.delete_key_reply)
}
inline ::kvstore::v1::DeleteKeyResponse* KVStoreWrapper::_internal_mutable_delete_key_reply() {
  if (!_internal_has_delete_key_reply()) {
    clear_payload();
    set_has_delete_key_reply();
    payload_.delete_key_reply_ = CreateMaybeMessage< ::kvstore::v1::DeleteKeyResponse >(GetArenaForAllocation());
  }
  return payload_.delete_key_reply_;
}
inline ::kvstore::v1::DeleteKeyResponse* KVStoreWrapper::mutable_delete_key_reply() {
  ::kvstore::v1::DeleteKeyResponse* _msg = _internal_mutable_delete_key_reply();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.KVStoreWrapper.delete_key_reply)
  return _msg;
}

// .kvstore.v1.GetBucketDescriptorRequest get_bucket_descriptor_request = 20 [json_name = "getBucketDescriptorRequest"];
inline bool KVStoreWrapper::_internal_has_get_bucket_descriptor_request() const {
  return payload_case() == kGetBucketDescriptorRequest;
}
inline bool KVStoreWrapper::has_get_bucket_descriptor_request() const {
  return _internal_has_get_bucket_descriptor_request();
}
inline void KVStoreWrapper::set_has_get_bucket_descriptor_request() {
  _oneof_case_[0] = kGetBucketDescriptorRequest;
}
inline void KVStoreWrapper::clear_get_bucket_descriptor_request() {
  if (_internal_has_get_bucket_descriptor_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.get_bucket_descriptor_request_;
    }
    clear_has_payload();
  }
}
inline ::kvstore::v1::GetBucketDescriptorRequest* KVStoreWrapper::release_get_bucket_descriptor_request() {
  // @@protoc_insertion_point(field_release:kvstore.v1.KVStoreWrapper.get_bucket_descriptor_request)
  if (_internal_has_get_bucket_descriptor_request()) {
    clear_has_payload();
    ::kvstore::v1::GetBucketDescriptorRequest* temp = payload_.get_bucket_descriptor_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.get_bucket_descriptor_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kvstore::v1::GetBucketDescriptorRequest& KVStoreWrapper::_internal_get_bucket_descriptor_request() const {
  return _internal_has_get_bucket_descriptor_request()
      ? *payload_.get_bucket_descriptor_request_
      : reinterpret_cast< ::kvstore::v1::GetBucketDescriptorRequest&>(::kvstore::v1::_GetBucketDescriptorRequest_default_instance_);
}
inline const ::kvstore::v1::GetBucketDescriptorRequest& KVStoreWrapper::get_bucket_descriptor_request() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KVStoreWrapper.get_bucket_descriptor_request)
  return _internal_get_bucket_descriptor_request();
}
inline ::kvstore::v1::GetBucketDescriptorRequest* KVStoreWrapper::unsafe_arena_release_get_bucket_descriptor_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kvstore.v1.KVStoreWrapper.get_bucket_descriptor_request)
  if (_internal_has_get_bucket_descriptor_request()) {
    clear_has_payload();
    ::kvstore::v1::GetBucketDescriptorRequest* temp = payload_.get_bucket_descriptor_request_;
    payload_.get_bucket_descriptor_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVStoreWrapper::unsafe_arena_set_allocated_get_bucket_descriptor_request(::kvstore::v1::GetBucketDescriptorRequest* get_bucket_descriptor_request) {
  clear_payload();
  if (get_bucket_descriptor_request) {
    set_has_get_bucket_descriptor_request();
    payload_.get_bucket_descriptor_request_ = get_bucket_descriptor_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.KVStoreWrapper.get_bucket_descriptor_request)
}
inline ::kvstore::v1::GetBucketDescriptorRequest* KVStoreWrapper::_internal_mutable_get_bucket_descriptor_request() {
  if (!_internal_has_get_bucket_descriptor_request()) {
    clear_payload();
    set_has_get_bucket_descriptor_request();
    payload_.get_bucket_descriptor_request_ = CreateMaybeMessage< ::kvstore::v1::GetBucketDescriptorRequest >(GetArenaForAllocation());
  }
  return payload_.get_bucket_descriptor_request_;
}
inline ::kvstore::v1::GetBucketDescriptorRequest* KVStoreWrapper::mutable_get_bucket_descriptor_request() {
  ::kvstore::v1::GetBucketDescriptorRequest* _msg = _internal_mutable_get_bucket_descriptor_request();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.KVStoreWrapper.get_bucket_descriptor_request)
  return _msg;
}

// .kvstore.v1.GetBucketDescriptorResponse get_bucket_descriptor_reply = 21 [json_name = "getBucketDescriptorReply"];
inline bool KVStoreWrapper::_internal_has_get_bucket_descriptor_reply() const {
  return payload_case() == kGetBucketDescriptorReply;
}
inline bool KVStoreWrapper::has_get_bucket_descriptor_reply() const {
  return _internal_has_get_bucket_descriptor_reply();
}
inline void KVStoreWrapper::set_has_get_bucket_descriptor_reply() {
  _oneof_case_[0] = kGetBucketDescriptorReply;
}
inline void KVStoreWrapper::clear_get_bucket_descriptor_reply() {
  if (_internal_has_get_bucket_descriptor_reply()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.get_bucket_descriptor_reply_;
    }
    clear_has_payload();
  }
}
inline ::kvstore::v1::GetBucketDescriptorResponse* KVStoreWrapper::release_get_bucket_descriptor_reply() {
  // @@protoc_insertion_point(field_release:kvstore.v1.KVStoreWrapper.get_bucket_descriptor_reply)
  if (_internal_has_get_bucket_descriptor_reply()) {
    clear_has_payload();
    ::kvstore::v1::GetBucketDescriptorResponse* temp = payload_.get_bucket_descriptor_reply_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.get_bucket_descriptor_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kvstore::v1::GetBucketDescriptorResponse& KVStoreWrapper::_internal_get_bucket_descriptor_reply() const {
  return _internal_has_get_bucket_descriptor_reply()
      ? *payload_.get_bucket_descriptor_reply_
      : reinterpret_cast< ::kvstore::v1::GetBucketDescriptorResponse&>(::kvstore::v1::_GetBucketDescriptorResponse_default_instance_);
}
inline const ::kvstore::v1::GetBucketDescriptorResponse& KVStoreWrapper::get_bucket_descriptor_reply() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KVStoreWrapper.get_bucket_descriptor_reply)
  return _internal_get_bucket_descriptor_reply();
}
inline ::kvstore::v1::GetBucketDescriptorResponse* KVStoreWrapper::unsafe_arena_release_get_bucket_descriptor_reply() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kvstore.v1.KVStoreWrapper.get_bucket_descriptor_reply)
  if (_internal_has_get_bucket_descriptor_reply()) {
    clear_has_payload();
    ::kvstore::v1::GetBucketDescriptorResponse* temp = payload_.get_bucket_descriptor_reply_;
    payload_.get_bucket_descriptor_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVStoreWrapper::unsafe_arena_set_allocated_get_bucket_descriptor_reply(::kvstore::v1::GetBucketDescriptorResponse* get_bucket_descriptor_reply) {
  clear_payload();
  if (get_bucket_descriptor_reply) {
    set_has_get_bucket_descriptor_reply();
    payload_.get_bucket_descriptor_reply_ = get_bucket_descriptor_reply;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.KVStoreWrapper.get_bucket_descriptor_reply)
}
inline ::kvstore::v1::GetBucketDescriptorResponse* KVStoreWrapper::_internal_mutable_get_bucket_descriptor_reply() {
  if (!_internal_has_get_bucket_descriptor_reply()) {
    clear_payload();
    set_has_get_bucket_descriptor_reply();
    payload_.get_bucket_descriptor_reply_ = CreateMaybeMessage< ::kvstore::v1::GetBucketDescriptorResponse >(GetArenaForAllocation());
  }
  return payload_.get_bucket_descriptor_reply_;
}
inline ::kvstore::v1::GetBucketDescriptorResponse* KVStoreWrapper::mutable_get_bucket_descriptor_reply() {
  ::kvstore::v1::GetBucketDescriptorResponse* _msg = _internal_mutable_get_bucket_descriptor_reply();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.KVStoreWrapper.get_bucket_descriptor_reply)
  return _msg;
}

// .errors.v1.Error error = 22 [json_name = "error"];
inline bool KVStoreWrapper::_internal_has_error() const {
  return payload_case() == kError;
}
inline bool KVStoreWrapper::has_error() const {
  return _internal_has_error();
}
inline void KVStoreWrapper::set_has_error() {
  _oneof_case_[0] = kError;
}
inline ::errors::v1::Error* KVStoreWrapper::release_error() {
  // @@protoc_insertion_point(field_release:kvstore.v1.KVStoreWrapper.error)
  if (_internal_has_error()) {
    clear_has_payload();
    ::errors::v1::Error* temp = payload_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::errors::v1::Error& KVStoreWrapper::_internal_error() const {
  return _internal_has_error()
      ? *payload_.error_
      : reinterpret_cast< ::errors::v1::Error&>(::errors::v1::_Error_default_instance_);
}
inline const ::errors::v1::Error& KVStoreWrapper::error() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KVStoreWrapper.error)
  return _internal_error();
}
inline ::errors::v1::Error* KVStoreWrapper::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kvstore.v1.KVStoreWrapper.error)
  if (_internal_has_error()) {
    clear_has_payload();
    ::errors::v1::Error* temp = payload_.error_;
    payload_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KVStoreWrapper::unsafe_arena_set_allocated_error(::errors::v1::Error* error) {
  clear_payload();
  if (error) {
    set_has_error();
    payload_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.KVStoreWrapper.error)
}
inline ::errors::v1::Error* KVStoreWrapper::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_payload();
    set_has_error();
    payload_.error_ = CreateMaybeMessage< ::errors::v1::Error >(GetArenaForAllocation());
  }
  return payload_.error_;
}
inline ::errors::v1::Error* KVStoreWrapper::mutable_error() {
  ::errors::v1::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.KVStoreWrapper.error)
  return _msg;
}

inline bool KVStoreWrapper::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void KVStoreWrapper::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline KVStoreWrapper::PayloadCase KVStoreWrapper::payload_case() const {
  return KVStoreWrapper::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CreateAccountRequest

// uint64 account_id = 1 [json_name = "accountId"];
inline void CreateAccountRequest::clear_account_id() {
  account_id_ = uint64_t{0u};
}
inline uint64_t CreateAccountRequest::_internal_account_id() const {
  return account_id_;
}
inline uint64_t CreateAccountRequest::account_id() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.CreateAccountRequest.account_id)
  return _internal_account_id();
}
inline void CreateAccountRequest::_internal_set_account_id(uint64_t value) {
  
  account_id_ = value;
}
inline void CreateAccountRequest::set_account_id(uint64_t value) {
  _internal_set_account_id(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.CreateAccountRequest.account_id)
}

// string owner = 2 [json_name = "owner"];
inline void CreateAccountRequest::clear_owner() {
  owner_.ClearToEmpty();
}
inline const std::string& CreateAccountRequest::owner() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.CreateAccountRequest.owner)
  return _internal_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateAccountRequest::set_owner(ArgT0&& arg0, ArgT... args) {
 
 owner_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kvstore.v1.CreateAccountRequest.owner)
}
inline std::string* CreateAccountRequest::mutable_owner() {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.CreateAccountRequest.owner)
  return _s;
}
inline const std::string& CreateAccountRequest::_internal_owner() const {
  return owner_.Get();
}
inline void CreateAccountRequest::_internal_set_owner(const std::string& value) {
  
  owner_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateAccountRequest::_internal_mutable_owner() {
  
  return owner_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateAccountRequest::release_owner() {
  // @@protoc_insertion_point(field_release:kvstore.v1.CreateAccountRequest.owner)
  return owner_.Release();
}
inline void CreateAccountRequest::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    
  } else {
    
  }
  owner_.SetAllocated(owner, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_.IsDefault()) {
    owner_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.CreateAccountRequest.owner)
}

// .kvstore.v1.Transaction transaction = 3 [json_name = "transaction"];
inline bool CreateAccountRequest::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool CreateAccountRequest::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::kvstore::v1::Transaction& CreateAccountRequest::_internal_transaction() const {
  const ::kvstore::v1::Transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::kvstore::v1::Transaction&>(
      ::kvstore::v1::_Transaction_default_instance_);
}
inline const ::kvstore::v1::Transaction& CreateAccountRequest::transaction() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.CreateAccountRequest.transaction)
  return _internal_transaction();
}
inline void CreateAccountRequest::unsafe_arena_set_allocated_transaction(
    ::kvstore::v1::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.CreateAccountRequest.transaction)
}
inline ::kvstore::v1::Transaction* CreateAccountRequest::release_transaction() {
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kvstore::v1::Transaction* CreateAccountRequest::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:kvstore.v1.CreateAccountRequest.transaction)
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::kvstore::v1::Transaction* CreateAccountRequest::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::kvstore::v1::Transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::kvstore::v1::Transaction* CreateAccountRequest::mutable_transaction() {
  ::kvstore::v1::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.CreateAccountRequest.transaction)
  return _msg;
}
inline void CreateAccountRequest::set_allocated_transaction(::kvstore::v1::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.CreateAccountRequest.transaction)
}

// -------------------------------------------------------------------

// CreateAccountResponse

// .kvstore.v1.AccountDescriptor account_descriptor = 1 [json_name = "accountDescriptor"];
inline bool CreateAccountResponse::_internal_has_account_descriptor() const {
  return this != internal_default_instance() && account_descriptor_ != nullptr;
}
inline bool CreateAccountResponse::has_account_descriptor() const {
  return _internal_has_account_descriptor();
}
inline void CreateAccountResponse::clear_account_descriptor() {
  if (GetArenaForAllocation() == nullptr && account_descriptor_ != nullptr) {
    delete account_descriptor_;
  }
  account_descriptor_ = nullptr;
}
inline const ::kvstore::v1::AccountDescriptor& CreateAccountResponse::_internal_account_descriptor() const {
  const ::kvstore::v1::AccountDescriptor* p = account_descriptor_;
  return p != nullptr ? *p : reinterpret_cast<const ::kvstore::v1::AccountDescriptor&>(
      ::kvstore::v1::_AccountDescriptor_default_instance_);
}
inline const ::kvstore::v1::AccountDescriptor& CreateAccountResponse::account_descriptor() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.CreateAccountResponse.account_descriptor)
  return _internal_account_descriptor();
}
inline void CreateAccountResponse::unsafe_arena_set_allocated_account_descriptor(
    ::kvstore::v1::AccountDescriptor* account_descriptor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_descriptor_);
  }
  account_descriptor_ = account_descriptor;
  if (account_descriptor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.CreateAccountResponse.account_descriptor)
}
inline ::kvstore::v1::AccountDescriptor* CreateAccountResponse::release_account_descriptor() {
  
  ::kvstore::v1::AccountDescriptor* temp = account_descriptor_;
  account_descriptor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kvstore::v1::AccountDescriptor* CreateAccountResponse::unsafe_arena_release_account_descriptor() {
  // @@protoc_insertion_point(field_release:kvstore.v1.CreateAccountResponse.account_descriptor)
  
  ::kvstore::v1::AccountDescriptor* temp = account_descriptor_;
  account_descriptor_ = nullptr;
  return temp;
}
inline ::kvstore::v1::AccountDescriptor* CreateAccountResponse::_internal_mutable_account_descriptor() {
  
  if (account_descriptor_ == nullptr) {
    auto* p = CreateMaybeMessage<::kvstore::v1::AccountDescriptor>(GetArenaForAllocation());
    account_descriptor_ = p;
  }
  return account_descriptor_;
}
inline ::kvstore::v1::AccountDescriptor* CreateAccountResponse::mutable_account_descriptor() {
  ::kvstore::v1::AccountDescriptor* _msg = _internal_mutable_account_descriptor();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.CreateAccountResponse.account_descriptor)
  return _msg;
}
inline void CreateAccountResponse::set_allocated_account_descriptor(::kvstore::v1::AccountDescriptor* account_descriptor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete account_descriptor_;
  }
  if (account_descriptor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(account_descriptor);
    if (message_arena != submessage_arena) {
      account_descriptor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account_descriptor, submessage_arena);
    }
    
  } else {
    
  }
  account_descriptor_ = account_descriptor;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.CreateAccountResponse.account_descriptor)
}

// .kvstore.v1.Transaction transaction = 2 [json_name = "transaction"];
inline bool CreateAccountResponse::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool CreateAccountResponse::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::kvstore::v1::Transaction& CreateAccountResponse::_internal_transaction() const {
  const ::kvstore::v1::Transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::kvstore::v1::Transaction&>(
      ::kvstore::v1::_Transaction_default_instance_);
}
inline const ::kvstore::v1::Transaction& CreateAccountResponse::transaction() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.CreateAccountResponse.transaction)
  return _internal_transaction();
}
inline void CreateAccountResponse::unsafe_arena_set_allocated_transaction(
    ::kvstore::v1::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.CreateAccountResponse.transaction)
}
inline ::kvstore::v1::Transaction* CreateAccountResponse::release_transaction() {
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kvstore::v1::Transaction* CreateAccountResponse::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:kvstore.v1.CreateAccountResponse.transaction)
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::kvstore::v1::Transaction* CreateAccountResponse::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::kvstore::v1::Transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::kvstore::v1::Transaction* CreateAccountResponse::mutable_transaction() {
  ::kvstore::v1::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.CreateAccountResponse.transaction)
  return _msg;
}
inline void CreateAccountResponse::set_allocated_transaction(::kvstore::v1::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.CreateAccountResponse.transaction)
}

// -------------------------------------------------------------------

// DeleteAccountRequest

// uint64 account_id = 1 [json_name = "accountId"];
inline void DeleteAccountRequest::clear_account_id() {
  account_id_ = uint64_t{0u};
}
inline uint64_t DeleteAccountRequest::_internal_account_id() const {
  return account_id_;
}
inline uint64_t DeleteAccountRequest::account_id() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.DeleteAccountRequest.account_id)
  return _internal_account_id();
}
inline void DeleteAccountRequest::_internal_set_account_id(uint64_t value) {
  
  account_id_ = value;
}
inline void DeleteAccountRequest::set_account_id(uint64_t value) {
  _internal_set_account_id(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.DeleteAccountRequest.account_id)
}

// string owner = 2 [json_name = "owner"];
inline void DeleteAccountRequest::clear_owner() {
  owner_.ClearToEmpty();
}
inline const std::string& DeleteAccountRequest::owner() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.DeleteAccountRequest.owner)
  return _internal_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteAccountRequest::set_owner(ArgT0&& arg0, ArgT... args) {
 
 owner_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kvstore.v1.DeleteAccountRequest.owner)
}
inline std::string* DeleteAccountRequest::mutable_owner() {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.DeleteAccountRequest.owner)
  return _s;
}
inline const std::string& DeleteAccountRequest::_internal_owner() const {
  return owner_.Get();
}
inline void DeleteAccountRequest::_internal_set_owner(const std::string& value) {
  
  owner_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteAccountRequest::_internal_mutable_owner() {
  
  return owner_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteAccountRequest::release_owner() {
  // @@protoc_insertion_point(field_release:kvstore.v1.DeleteAccountRequest.owner)
  return owner_.Release();
}
inline void DeleteAccountRequest::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    
  } else {
    
  }
  owner_.SetAllocated(owner, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_.IsDefault()) {
    owner_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.DeleteAccountRequest.owner)
}

// .kvstore.v1.Transaction transaction = 3 [json_name = "transaction"];
inline bool DeleteAccountRequest::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool DeleteAccountRequest::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::kvstore::v1::Transaction& DeleteAccountRequest::_internal_transaction() const {
  const ::kvstore::v1::Transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::kvstore::v1::Transaction&>(
      ::kvstore::v1::_Transaction_default_instance_);
}
inline const ::kvstore::v1::Transaction& DeleteAccountRequest::transaction() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.DeleteAccountRequest.transaction)
  return _internal_transaction();
}
inline void DeleteAccountRequest::unsafe_arena_set_allocated_transaction(
    ::kvstore::v1::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.DeleteAccountRequest.transaction)
}
inline ::kvstore::v1::Transaction* DeleteAccountRequest::release_transaction() {
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kvstore::v1::Transaction* DeleteAccountRequest::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:kvstore.v1.DeleteAccountRequest.transaction)
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::kvstore::v1::Transaction* DeleteAccountRequest::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::kvstore::v1::Transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::kvstore::v1::Transaction* DeleteAccountRequest::mutable_transaction() {
  ::kvstore::v1::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.DeleteAccountRequest.transaction)
  return _msg;
}
inline void DeleteAccountRequest::set_allocated_transaction(::kvstore::v1::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.DeleteAccountRequest.transaction)
}

// -------------------------------------------------------------------

// DeleteAccountResponse

// bool ok = 1 [json_name = "ok"];
inline void DeleteAccountResponse::clear_ok() {
  ok_ = false;
}
inline bool DeleteAccountResponse::_internal_ok() const {
  return ok_;
}
inline bool DeleteAccountResponse::ok() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.DeleteAccountResponse.ok)
  return _internal_ok();
}
inline void DeleteAccountResponse::_internal_set_ok(bool value) {
  
  ok_ = value;
}
inline void DeleteAccountResponse::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.DeleteAccountResponse.ok)
}

// .kvstore.v1.Transaction transaction = 2 [json_name = "transaction"];
inline bool DeleteAccountResponse::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool DeleteAccountResponse::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::kvstore::v1::Transaction& DeleteAccountResponse::_internal_transaction() const {
  const ::kvstore::v1::Transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::kvstore::v1::Transaction&>(
      ::kvstore::v1::_Transaction_default_instance_);
}
inline const ::kvstore::v1::Transaction& DeleteAccountResponse::transaction() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.DeleteAccountResponse.transaction)
  return _internal_transaction();
}
inline void DeleteAccountResponse::unsafe_arena_set_allocated_transaction(
    ::kvstore::v1::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.DeleteAccountResponse.transaction)
}
inline ::kvstore::v1::Transaction* DeleteAccountResponse::release_transaction() {
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kvstore::v1::Transaction* DeleteAccountResponse::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:kvstore.v1.DeleteAccountResponse.transaction)
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::kvstore::v1::Transaction* DeleteAccountResponse::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::kvstore::v1::Transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::kvstore::v1::Transaction* DeleteAccountResponse::mutable_transaction() {
  ::kvstore::v1::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.DeleteAccountResponse.transaction)
  return _msg;
}
inline void DeleteAccountResponse::set_allocated_transaction(::kvstore::v1::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.DeleteAccountResponse.transaction)
}

// -------------------------------------------------------------------

// GetAccountDescriptorRequest

// uint64 account_id = 1 [json_name = "accountId"];
inline void GetAccountDescriptorRequest::clear_account_id() {
  account_id_ = uint64_t{0u};
}
inline uint64_t GetAccountDescriptorRequest::_internal_account_id() const {
  return account_id_;
}
inline uint64_t GetAccountDescriptorRequest::account_id() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.GetAccountDescriptorRequest.account_id)
  return _internal_account_id();
}
inline void GetAccountDescriptorRequest::_internal_set_account_id(uint64_t value) {
  
  account_id_ = value;
}
inline void GetAccountDescriptorRequest::set_account_id(uint64_t value) {
  _internal_set_account_id(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.GetAccountDescriptorRequest.account_id)
}

// -------------------------------------------------------------------

// GetAccountDescriptorResponse

// .kvstore.v1.AccountDescriptor account_descriptor = 1 [json_name = "accountDescriptor"];
inline bool GetAccountDescriptorResponse::_internal_has_account_descriptor() const {
  return this != internal_default_instance() && account_descriptor_ != nullptr;
}
inline bool GetAccountDescriptorResponse::has_account_descriptor() const {
  return _internal_has_account_descriptor();
}
inline void GetAccountDescriptorResponse::clear_account_descriptor() {
  if (GetArenaForAllocation() == nullptr && account_descriptor_ != nullptr) {
    delete account_descriptor_;
  }
  account_descriptor_ = nullptr;
}
inline const ::kvstore::v1::AccountDescriptor& GetAccountDescriptorResponse::_internal_account_descriptor() const {
  const ::kvstore::v1::AccountDescriptor* p = account_descriptor_;
  return p != nullptr ? *p : reinterpret_cast<const ::kvstore::v1::AccountDescriptor&>(
      ::kvstore::v1::_AccountDescriptor_default_instance_);
}
inline const ::kvstore::v1::AccountDescriptor& GetAccountDescriptorResponse::account_descriptor() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.GetAccountDescriptorResponse.account_descriptor)
  return _internal_account_descriptor();
}
inline void GetAccountDescriptorResponse::unsafe_arena_set_allocated_account_descriptor(
    ::kvstore::v1::AccountDescriptor* account_descriptor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_descriptor_);
  }
  account_descriptor_ = account_descriptor;
  if (account_descriptor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.GetAccountDescriptorResponse.account_descriptor)
}
inline ::kvstore::v1::AccountDescriptor* GetAccountDescriptorResponse::release_account_descriptor() {
  
  ::kvstore::v1::AccountDescriptor* temp = account_descriptor_;
  account_descriptor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kvstore::v1::AccountDescriptor* GetAccountDescriptorResponse::unsafe_arena_release_account_descriptor() {
  // @@protoc_insertion_point(field_release:kvstore.v1.GetAccountDescriptorResponse.account_descriptor)
  
  ::kvstore::v1::AccountDescriptor* temp = account_descriptor_;
  account_descriptor_ = nullptr;
  return temp;
}
inline ::kvstore::v1::AccountDescriptor* GetAccountDescriptorResponse::_internal_mutable_account_descriptor() {
  
  if (account_descriptor_ == nullptr) {
    auto* p = CreateMaybeMessage<::kvstore::v1::AccountDescriptor>(GetArenaForAllocation());
    account_descriptor_ = p;
  }
  return account_descriptor_;
}
inline ::kvstore::v1::AccountDescriptor* GetAccountDescriptorResponse::mutable_account_descriptor() {
  ::kvstore::v1::AccountDescriptor* _msg = _internal_mutable_account_descriptor();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.GetAccountDescriptorResponse.account_descriptor)
  return _msg;
}
inline void GetAccountDescriptorResponse::set_allocated_account_descriptor(::kvstore::v1::AccountDescriptor* account_descriptor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete account_descriptor_;
  }
  if (account_descriptor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(account_descriptor);
    if (message_arena != submessage_arena) {
      account_descriptor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account_descriptor, submessage_arena);
    }
    
  } else {
    
  }
  account_descriptor_ = account_descriptor;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.GetAccountDescriptorResponse.account_descriptor)
}

// -------------------------------------------------------------------

// AccountDescriptor

// uint64 account_id = 1 [json_name = "accountId"];
inline void AccountDescriptor::clear_account_id() {
  account_id_ = uint64_t{0u};
}
inline uint64_t AccountDescriptor::_internal_account_id() const {
  return account_id_;
}
inline uint64_t AccountDescriptor::account_id() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.AccountDescriptor.account_id)
  return _internal_account_id();
}
inline void AccountDescriptor::_internal_set_account_id(uint64_t value) {
  
  account_id_ = value;
}
inline void AccountDescriptor::set_account_id(uint64_t value) {
  _internal_set_account_id(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.AccountDescriptor.account_id)
}

// string owner = 2 [json_name = "owner"];
inline void AccountDescriptor::clear_owner() {
  owner_.ClearToEmpty();
}
inline const std::string& AccountDescriptor::owner() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.AccountDescriptor.owner)
  return _internal_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountDescriptor::set_owner(ArgT0&& arg0, ArgT... args) {
 
 owner_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kvstore.v1.AccountDescriptor.owner)
}
inline std::string* AccountDescriptor::mutable_owner() {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.AccountDescriptor.owner)
  return _s;
}
inline const std::string& AccountDescriptor::_internal_owner() const {
  return owner_.Get();
}
inline void AccountDescriptor::_internal_set_owner(const std::string& value) {
  
  owner_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountDescriptor::_internal_mutable_owner() {
  
  return owner_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountDescriptor::release_owner() {
  // @@protoc_insertion_point(field_release:kvstore.v1.AccountDescriptor.owner)
  return owner_.Release();
}
inline void AccountDescriptor::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    
  } else {
    
  }
  owner_.SetAllocated(owner, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_.IsDefault()) {
    owner_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.AccountDescriptor.owner)
}

// .google.protobuf.Timestamp created = 3 [json_name = "created"];
inline bool AccountDescriptor::_internal_has_created() const {
  return this != internal_default_instance() && created_ != nullptr;
}
inline bool AccountDescriptor::has_created() const {
  return _internal_has_created();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AccountDescriptor::_internal_created() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AccountDescriptor::created() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.AccountDescriptor.created)
  return _internal_created();
}
inline void AccountDescriptor::unsafe_arena_set_allocated_created(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_);
  }
  created_ = created;
  if (created) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.AccountDescriptor.created)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AccountDescriptor::release_created() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_;
  created_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AccountDescriptor::unsafe_arena_release_created() {
  // @@protoc_insertion_point(field_release:kvstore.v1.AccountDescriptor.created)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_;
  created_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AccountDescriptor::_internal_mutable_created() {
  
  if (created_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_ = p;
  }
  return created_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AccountDescriptor::mutable_created() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.AccountDescriptor.created)
  return _msg;
}
inline void AccountDescriptor::set_allocated_created(::PROTOBUF_NAMESPACE_ID::Timestamp* created) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_);
  }
  if (created) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created));
    if (message_arena != submessage_arena) {
      created = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created, submessage_arena);
    }
    
  } else {
    
  }
  created_ = created;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.AccountDescriptor.created)
}

// .google.protobuf.Timestamp last_updated = 4 [json_name = "lastUpdated"];
inline bool AccountDescriptor::_internal_has_last_updated() const {
  return this != internal_default_instance() && last_updated_ != nullptr;
}
inline bool AccountDescriptor::has_last_updated() const {
  return _internal_has_last_updated();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AccountDescriptor::_internal_last_updated() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = last_updated_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AccountDescriptor::last_updated() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.AccountDescriptor.last_updated)
  return _internal_last_updated();
}
inline void AccountDescriptor::unsafe_arena_set_allocated_last_updated(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_updated_);
  }
  last_updated_ = last_updated;
  if (last_updated) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.AccountDescriptor.last_updated)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AccountDescriptor::release_last_updated() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_updated_;
  last_updated_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AccountDescriptor::unsafe_arena_release_last_updated() {
  // @@protoc_insertion_point(field_release:kvstore.v1.AccountDescriptor.last_updated)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_updated_;
  last_updated_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AccountDescriptor::_internal_mutable_last_updated() {
  
  if (last_updated_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    last_updated_ = p;
  }
  return last_updated_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AccountDescriptor::mutable_last_updated() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_updated();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.AccountDescriptor.last_updated)
  return _msg;
}
inline void AccountDescriptor::set_allocated_last_updated(::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_updated_);
  }
  if (last_updated) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_updated));
    if (message_arena != submessage_arena) {
      last_updated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_updated, submessage_arena);
    }
    
  } else {
    
  }
  last_updated_ = last_updated;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.AccountDescriptor.last_updated)
}

// uint64 bucket_count = 5 [json_name = "bucketCount"];
inline void AccountDescriptor::clear_bucket_count() {
  bucket_count_ = uint64_t{0u};
}
inline uint64_t AccountDescriptor::_internal_bucket_count() const {
  return bucket_count_;
}
inline uint64_t AccountDescriptor::bucket_count() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.AccountDescriptor.bucket_count)
  return _internal_bucket_count();
}
inline void AccountDescriptor::_internal_set_bucket_count(uint64_t value) {
  
  bucket_count_ = value;
}
inline void AccountDescriptor::set_bucket_count(uint64_t value) {
  _internal_set_bucket_count(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.AccountDescriptor.bucket_count)
}

// repeated string buckets = 6 [json_name = "buckets"];
inline int AccountDescriptor::_internal_buckets_size() const {
  return buckets_.size();
}
inline int AccountDescriptor::buckets_size() const {
  return _internal_buckets_size();
}
inline void AccountDescriptor::clear_buckets() {
  buckets_.Clear();
}
inline std::string* AccountDescriptor::add_buckets() {
  std::string* _s = _internal_add_buckets();
  // @@protoc_insertion_point(field_add_mutable:kvstore.v1.AccountDescriptor.buckets)
  return _s;
}
inline const std::string& AccountDescriptor::_internal_buckets(int index) const {
  return buckets_.Get(index);
}
inline const std::string& AccountDescriptor::buckets(int index) const {
  // @@protoc_insertion_point(field_get:kvstore.v1.AccountDescriptor.buckets)
  return _internal_buckets(index);
}
inline std::string* AccountDescriptor::mutable_buckets(int index) {
  // @@protoc_insertion_point(field_mutable:kvstore.v1.AccountDescriptor.buckets)
  return buckets_.Mutable(index);
}
inline void AccountDescriptor::set_buckets(int index, const std::string& value) {
  buckets_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.AccountDescriptor.buckets)
}
inline void AccountDescriptor::set_buckets(int index, std::string&& value) {
  buckets_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:kvstore.v1.AccountDescriptor.buckets)
}
inline void AccountDescriptor::set_buckets(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  buckets_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kvstore.v1.AccountDescriptor.buckets)
}
inline void AccountDescriptor::set_buckets(int index, const char* value, size_t size) {
  buckets_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvstore.v1.AccountDescriptor.buckets)
}
inline std::string* AccountDescriptor::_internal_add_buckets() {
  return buckets_.Add();
}
inline void AccountDescriptor::add_buckets(const std::string& value) {
  buckets_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kvstore.v1.AccountDescriptor.buckets)
}
inline void AccountDescriptor::add_buckets(std::string&& value) {
  buckets_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kvstore.v1.AccountDescriptor.buckets)
}
inline void AccountDescriptor::add_buckets(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  buckets_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kvstore.v1.AccountDescriptor.buckets)
}
inline void AccountDescriptor::add_buckets(const char* value, size_t size) {
  buckets_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kvstore.v1.AccountDescriptor.buckets)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AccountDescriptor::buckets() const {
  // @@protoc_insertion_point(field_list:kvstore.v1.AccountDescriptor.buckets)
  return buckets_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AccountDescriptor::mutable_buckets() {
  // @@protoc_insertion_point(field_mutable_list:kvstore.v1.AccountDescriptor.buckets)
  return &buckets_;
}

// -------------------------------------------------------------------

// CreateBucketRequest

// uint64 account_id = 1 [json_name = "accountId"];
inline void CreateBucketRequest::clear_account_id() {
  account_id_ = uint64_t{0u};
}
inline uint64_t CreateBucketRequest::_internal_account_id() const {
  return account_id_;
}
inline uint64_t CreateBucketRequest::account_id() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.CreateBucketRequest.account_id)
  return _internal_account_id();
}
inline void CreateBucketRequest::_internal_set_account_id(uint64_t value) {
  
  account_id_ = value;
}
inline void CreateBucketRequest::set_account_id(uint64_t value) {
  _internal_set_account_id(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.CreateBucketRequest.account_id)
}

// string name = 2 [json_name = "name"];
inline void CreateBucketRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateBucketRequest::name() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.CreateBucketRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateBucketRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kvstore.v1.CreateBucketRequest.name)
}
inline std::string* CreateBucketRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.CreateBucketRequest.name)
  return _s;
}
inline const std::string& CreateBucketRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateBucketRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateBucketRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateBucketRequest::release_name() {
  // @@protoc_insertion_point(field_release:kvstore.v1.CreateBucketRequest.name)
  return name_.Release();
}
inline void CreateBucketRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.CreateBucketRequest.name)
}

// string owner = 3 [json_name = "owner"];
inline void CreateBucketRequest::clear_owner() {
  owner_.ClearToEmpty();
}
inline const std::string& CreateBucketRequest::owner() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.CreateBucketRequest.owner)
  return _internal_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateBucketRequest::set_owner(ArgT0&& arg0, ArgT... args) {
 
 owner_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kvstore.v1.CreateBucketRequest.owner)
}
inline std::string* CreateBucketRequest::mutable_owner() {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.CreateBucketRequest.owner)
  return _s;
}
inline const std::string& CreateBucketRequest::_internal_owner() const {
  return owner_.Get();
}
inline void CreateBucketRequest::_internal_set_owner(const std::string& value) {
  
  owner_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateBucketRequest::_internal_mutable_owner() {
  
  return owner_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateBucketRequest::release_owner() {
  // @@protoc_insertion_point(field_release:kvstore.v1.CreateBucketRequest.owner)
  return owner_.Release();
}
inline void CreateBucketRequest::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    
  } else {
    
  }
  owner_.SetAllocated(owner, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_.IsDefault()) {
    owner_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.CreateBucketRequest.owner)
}

// .kvstore.v1.Transaction transaction = 4 [json_name = "transaction"];
inline bool CreateBucketRequest::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool CreateBucketRequest::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::kvstore::v1::Transaction& CreateBucketRequest::_internal_transaction() const {
  const ::kvstore::v1::Transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::kvstore::v1::Transaction&>(
      ::kvstore::v1::_Transaction_default_instance_);
}
inline const ::kvstore::v1::Transaction& CreateBucketRequest::transaction() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.CreateBucketRequest.transaction)
  return _internal_transaction();
}
inline void CreateBucketRequest::unsafe_arena_set_allocated_transaction(
    ::kvstore::v1::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.CreateBucketRequest.transaction)
}
inline ::kvstore::v1::Transaction* CreateBucketRequest::release_transaction() {
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kvstore::v1::Transaction* CreateBucketRequest::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:kvstore.v1.CreateBucketRequest.transaction)
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::kvstore::v1::Transaction* CreateBucketRequest::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::kvstore::v1::Transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::kvstore::v1::Transaction* CreateBucketRequest::mutable_transaction() {
  ::kvstore::v1::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.CreateBucketRequest.transaction)
  return _msg;
}
inline void CreateBucketRequest::set_allocated_transaction(::kvstore::v1::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.CreateBucketRequest.transaction)
}

// -------------------------------------------------------------------

// CreateBucketResponse

// .kvstore.v1.BucketDescriptor bucket_descriptor = 1 [json_name = "bucketDescriptor"];
inline bool CreateBucketResponse::_internal_has_bucket_descriptor() const {
  return this != internal_default_instance() && bucket_descriptor_ != nullptr;
}
inline bool CreateBucketResponse::has_bucket_descriptor() const {
  return _internal_has_bucket_descriptor();
}
inline void CreateBucketResponse::clear_bucket_descriptor() {
  if (GetArenaForAllocation() == nullptr && bucket_descriptor_ != nullptr) {
    delete bucket_descriptor_;
  }
  bucket_descriptor_ = nullptr;
}
inline const ::kvstore::v1::BucketDescriptor& CreateBucketResponse::_internal_bucket_descriptor() const {
  const ::kvstore::v1::BucketDescriptor* p = bucket_descriptor_;
  return p != nullptr ? *p : reinterpret_cast<const ::kvstore::v1::BucketDescriptor&>(
      ::kvstore::v1::_BucketDescriptor_default_instance_);
}
inline const ::kvstore::v1::BucketDescriptor& CreateBucketResponse::bucket_descriptor() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.CreateBucketResponse.bucket_descriptor)
  return _internal_bucket_descriptor();
}
inline void CreateBucketResponse::unsafe_arena_set_allocated_bucket_descriptor(
    ::kvstore::v1::BucketDescriptor* bucket_descriptor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bucket_descriptor_);
  }
  bucket_descriptor_ = bucket_descriptor;
  if (bucket_descriptor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.CreateBucketResponse.bucket_descriptor)
}
inline ::kvstore::v1::BucketDescriptor* CreateBucketResponse::release_bucket_descriptor() {
  
  ::kvstore::v1::BucketDescriptor* temp = bucket_descriptor_;
  bucket_descriptor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kvstore::v1::BucketDescriptor* CreateBucketResponse::unsafe_arena_release_bucket_descriptor() {
  // @@protoc_insertion_point(field_release:kvstore.v1.CreateBucketResponse.bucket_descriptor)
  
  ::kvstore::v1::BucketDescriptor* temp = bucket_descriptor_;
  bucket_descriptor_ = nullptr;
  return temp;
}
inline ::kvstore::v1::BucketDescriptor* CreateBucketResponse::_internal_mutable_bucket_descriptor() {
  
  if (bucket_descriptor_ == nullptr) {
    auto* p = CreateMaybeMessage<::kvstore::v1::BucketDescriptor>(GetArenaForAllocation());
    bucket_descriptor_ = p;
  }
  return bucket_descriptor_;
}
inline ::kvstore::v1::BucketDescriptor* CreateBucketResponse::mutable_bucket_descriptor() {
  ::kvstore::v1::BucketDescriptor* _msg = _internal_mutable_bucket_descriptor();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.CreateBucketResponse.bucket_descriptor)
  return _msg;
}
inline void CreateBucketResponse::set_allocated_bucket_descriptor(::kvstore::v1::BucketDescriptor* bucket_descriptor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bucket_descriptor_;
  }
  if (bucket_descriptor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bucket_descriptor);
    if (message_arena != submessage_arena) {
      bucket_descriptor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bucket_descriptor, submessage_arena);
    }
    
  } else {
    
  }
  bucket_descriptor_ = bucket_descriptor;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.CreateBucketResponse.bucket_descriptor)
}

// .kvstore.v1.Transaction transaction = 2 [json_name = "transaction"];
inline bool CreateBucketResponse::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool CreateBucketResponse::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::kvstore::v1::Transaction& CreateBucketResponse::_internal_transaction() const {
  const ::kvstore::v1::Transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::kvstore::v1::Transaction&>(
      ::kvstore::v1::_Transaction_default_instance_);
}
inline const ::kvstore::v1::Transaction& CreateBucketResponse::transaction() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.CreateBucketResponse.transaction)
  return _internal_transaction();
}
inline void CreateBucketResponse::unsafe_arena_set_allocated_transaction(
    ::kvstore::v1::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.CreateBucketResponse.transaction)
}
inline ::kvstore::v1::Transaction* CreateBucketResponse::release_transaction() {
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kvstore::v1::Transaction* CreateBucketResponse::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:kvstore.v1.CreateBucketResponse.transaction)
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::kvstore::v1::Transaction* CreateBucketResponse::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::kvstore::v1::Transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::kvstore::v1::Transaction* CreateBucketResponse::mutable_transaction() {
  ::kvstore::v1::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.CreateBucketResponse.transaction)
  return _msg;
}
inline void CreateBucketResponse::set_allocated_transaction(::kvstore::v1::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.CreateBucketResponse.transaction)
}

// -------------------------------------------------------------------

// DeleteBucketRequest

// uint64 account_id = 1 [json_name = "accountId"];
inline void DeleteBucketRequest::clear_account_id() {
  account_id_ = uint64_t{0u};
}
inline uint64_t DeleteBucketRequest::_internal_account_id() const {
  return account_id_;
}
inline uint64_t DeleteBucketRequest::account_id() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.DeleteBucketRequest.account_id)
  return _internal_account_id();
}
inline void DeleteBucketRequest::_internal_set_account_id(uint64_t value) {
  
  account_id_ = value;
}
inline void DeleteBucketRequest::set_account_id(uint64_t value) {
  _internal_set_account_id(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.DeleteBucketRequest.account_id)
}

// string name = 2 [json_name = "name"];
inline void DeleteBucketRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& DeleteBucketRequest::name() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.DeleteBucketRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteBucketRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kvstore.v1.DeleteBucketRequest.name)
}
inline std::string* DeleteBucketRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.DeleteBucketRequest.name)
  return _s;
}
inline const std::string& DeleteBucketRequest::_internal_name() const {
  return name_.Get();
}
inline void DeleteBucketRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteBucketRequest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteBucketRequest::release_name() {
  // @@protoc_insertion_point(field_release:kvstore.v1.DeleteBucketRequest.name)
  return name_.Release();
}
inline void DeleteBucketRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.DeleteBucketRequest.name)
}

// .kvstore.v1.Transaction transaction = 3 [json_name = "transaction"];
inline bool DeleteBucketRequest::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool DeleteBucketRequest::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::kvstore::v1::Transaction& DeleteBucketRequest::_internal_transaction() const {
  const ::kvstore::v1::Transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::kvstore::v1::Transaction&>(
      ::kvstore::v1::_Transaction_default_instance_);
}
inline const ::kvstore::v1::Transaction& DeleteBucketRequest::transaction() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.DeleteBucketRequest.transaction)
  return _internal_transaction();
}
inline void DeleteBucketRequest::unsafe_arena_set_allocated_transaction(
    ::kvstore::v1::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.DeleteBucketRequest.transaction)
}
inline ::kvstore::v1::Transaction* DeleteBucketRequest::release_transaction() {
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kvstore::v1::Transaction* DeleteBucketRequest::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:kvstore.v1.DeleteBucketRequest.transaction)
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::kvstore::v1::Transaction* DeleteBucketRequest::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::kvstore::v1::Transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::kvstore::v1::Transaction* DeleteBucketRequest::mutable_transaction() {
  ::kvstore::v1::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.DeleteBucketRequest.transaction)
  return _msg;
}
inline void DeleteBucketRequest::set_allocated_transaction(::kvstore::v1::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.DeleteBucketRequest.transaction)
}

// -------------------------------------------------------------------

// DeleteBucketResponse

// bool ok = 1 [json_name = "ok"];
inline void DeleteBucketResponse::clear_ok() {
  ok_ = false;
}
inline bool DeleteBucketResponse::_internal_ok() const {
  return ok_;
}
inline bool DeleteBucketResponse::ok() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.DeleteBucketResponse.ok)
  return _internal_ok();
}
inline void DeleteBucketResponse::_internal_set_ok(bool value) {
  
  ok_ = value;
}
inline void DeleteBucketResponse::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.DeleteBucketResponse.ok)
}

// .kvstore.v1.Transaction transaction = 2 [json_name = "transaction"];
inline bool DeleteBucketResponse::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool DeleteBucketResponse::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::kvstore::v1::Transaction& DeleteBucketResponse::_internal_transaction() const {
  const ::kvstore::v1::Transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::kvstore::v1::Transaction&>(
      ::kvstore::v1::_Transaction_default_instance_);
}
inline const ::kvstore::v1::Transaction& DeleteBucketResponse::transaction() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.DeleteBucketResponse.transaction)
  return _internal_transaction();
}
inline void DeleteBucketResponse::unsafe_arena_set_allocated_transaction(
    ::kvstore::v1::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.DeleteBucketResponse.transaction)
}
inline ::kvstore::v1::Transaction* DeleteBucketResponse::release_transaction() {
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kvstore::v1::Transaction* DeleteBucketResponse::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:kvstore.v1.DeleteBucketResponse.transaction)
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::kvstore::v1::Transaction* DeleteBucketResponse::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::kvstore::v1::Transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::kvstore::v1::Transaction* DeleteBucketResponse::mutable_transaction() {
  ::kvstore::v1::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.DeleteBucketResponse.transaction)
  return _msg;
}
inline void DeleteBucketResponse::set_allocated_transaction(::kvstore::v1::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.DeleteBucketResponse.transaction)
}

// -------------------------------------------------------------------

// BucketDescriptor

// string owner = 1 [json_name = "owner"];
inline void BucketDescriptor::clear_owner() {
  owner_.ClearToEmpty();
}
inline const std::string& BucketDescriptor::owner() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.BucketDescriptor.owner)
  return _internal_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BucketDescriptor::set_owner(ArgT0&& arg0, ArgT... args) {
 
 owner_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kvstore.v1.BucketDescriptor.owner)
}
inline std::string* BucketDescriptor::mutable_owner() {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.BucketDescriptor.owner)
  return _s;
}
inline const std::string& BucketDescriptor::_internal_owner() const {
  return owner_.Get();
}
inline void BucketDescriptor::_internal_set_owner(const std::string& value) {
  
  owner_.Set(value, GetArenaForAllocation());
}
inline std::string* BucketDescriptor::_internal_mutable_owner() {
  
  return owner_.Mutable(GetArenaForAllocation());
}
inline std::string* BucketDescriptor::release_owner() {
  // @@protoc_insertion_point(field_release:kvstore.v1.BucketDescriptor.owner)
  return owner_.Release();
}
inline void BucketDescriptor::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    
  } else {
    
  }
  owner_.SetAllocated(owner, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_.IsDefault()) {
    owner_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.BucketDescriptor.owner)
}

// uint64 size = 2 [json_name = "size"];
inline void BucketDescriptor::clear_size() {
  size_ = uint64_t{0u};
}
inline uint64_t BucketDescriptor::_internal_size() const {
  return size_;
}
inline uint64_t BucketDescriptor::size() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.BucketDescriptor.size)
  return _internal_size();
}
inline void BucketDescriptor::_internal_set_size(uint64_t value) {
  
  size_ = value;
}
inline void BucketDescriptor::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.BucketDescriptor.size)
}

// uint64 key_count = 3 [json_name = "keyCount"];
inline void BucketDescriptor::clear_key_count() {
  key_count_ = uint64_t{0u};
}
inline uint64_t BucketDescriptor::_internal_key_count() const {
  return key_count_;
}
inline uint64_t BucketDescriptor::key_count() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.BucketDescriptor.key_count)
  return _internal_key_count();
}
inline void BucketDescriptor::_internal_set_key_count(uint64_t value) {
  
  key_count_ = value;
}
inline void BucketDescriptor::set_key_count(uint64_t value) {
  _internal_set_key_count(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.BucketDescriptor.key_count)
}

// .google.protobuf.Timestamp created = 4 [json_name = "created"];
inline bool BucketDescriptor::_internal_has_created() const {
  return this != internal_default_instance() && created_ != nullptr;
}
inline bool BucketDescriptor::has_created() const {
  return _internal_has_created();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& BucketDescriptor::_internal_created() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& BucketDescriptor::created() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.BucketDescriptor.created)
  return _internal_created();
}
inline void BucketDescriptor::unsafe_arena_set_allocated_created(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_);
  }
  created_ = created;
  if (created) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.BucketDescriptor.created)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BucketDescriptor::release_created() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_;
  created_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BucketDescriptor::unsafe_arena_release_created() {
  // @@protoc_insertion_point(field_release:kvstore.v1.BucketDescriptor.created)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_;
  created_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BucketDescriptor::_internal_mutable_created() {
  
  if (created_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_ = p;
  }
  return created_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BucketDescriptor::mutable_created() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.BucketDescriptor.created)
  return _msg;
}
inline void BucketDescriptor::set_allocated_created(::PROTOBUF_NAMESPACE_ID::Timestamp* created) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_);
  }
  if (created) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created));
    if (message_arena != submessage_arena) {
      created = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created, submessage_arena);
    }
    
  } else {
    
  }
  created_ = created;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.BucketDescriptor.created)
}

// .google.protobuf.Timestamp last_updated = 5 [json_name = "lastUpdated"];
inline bool BucketDescriptor::_internal_has_last_updated() const {
  return this != internal_default_instance() && last_updated_ != nullptr;
}
inline bool BucketDescriptor::has_last_updated() const {
  return _internal_has_last_updated();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& BucketDescriptor::_internal_last_updated() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = last_updated_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& BucketDescriptor::last_updated() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.BucketDescriptor.last_updated)
  return _internal_last_updated();
}
inline void BucketDescriptor::unsafe_arena_set_allocated_last_updated(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_updated_);
  }
  last_updated_ = last_updated;
  if (last_updated) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.BucketDescriptor.last_updated)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BucketDescriptor::release_last_updated() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_updated_;
  last_updated_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BucketDescriptor::unsafe_arena_release_last_updated() {
  // @@protoc_insertion_point(field_release:kvstore.v1.BucketDescriptor.last_updated)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_updated_;
  last_updated_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BucketDescriptor::_internal_mutable_last_updated() {
  
  if (last_updated_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    last_updated_ = p;
  }
  return last_updated_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* BucketDescriptor::mutable_last_updated() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_updated();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.BucketDescriptor.last_updated)
  return _msg;
}
inline void BucketDescriptor::set_allocated_last_updated(::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_updated_);
  }
  if (last_updated) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_updated));
    if (message_arena != submessage_arena) {
      last_updated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_updated, submessage_arena);
    }
    
  } else {
    
  }
  last_updated_ = last_updated;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.BucketDescriptor.last_updated)
}

// -------------------------------------------------------------------

// GetBucketDescriptorRequest

// uint64 account_id = 1 [json_name = "accountId"];
inline void GetBucketDescriptorRequest::clear_account_id() {
  account_id_ = uint64_t{0u};
}
inline uint64_t GetBucketDescriptorRequest::_internal_account_id() const {
  return account_id_;
}
inline uint64_t GetBucketDescriptorRequest::account_id() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.GetBucketDescriptorRequest.account_id)
  return _internal_account_id();
}
inline void GetBucketDescriptorRequest::_internal_set_account_id(uint64_t value) {
  
  account_id_ = value;
}
inline void GetBucketDescriptorRequest::set_account_id(uint64_t value) {
  _internal_set_account_id(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.GetBucketDescriptorRequest.account_id)
}

// string bucket_name = 2 [json_name = "bucketName"];
inline void GetBucketDescriptorRequest::clear_bucket_name() {
  bucket_name_.ClearToEmpty();
}
inline const std::string& GetBucketDescriptorRequest::bucket_name() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.GetBucketDescriptorRequest.bucket_name)
  return _internal_bucket_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBucketDescriptorRequest::set_bucket_name(ArgT0&& arg0, ArgT... args) {
 
 bucket_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kvstore.v1.GetBucketDescriptorRequest.bucket_name)
}
inline std::string* GetBucketDescriptorRequest::mutable_bucket_name() {
  std::string* _s = _internal_mutable_bucket_name();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.GetBucketDescriptorRequest.bucket_name)
  return _s;
}
inline const std::string& GetBucketDescriptorRequest::_internal_bucket_name() const {
  return bucket_name_.Get();
}
inline void GetBucketDescriptorRequest::_internal_set_bucket_name(const std::string& value) {
  
  bucket_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBucketDescriptorRequest::_internal_mutable_bucket_name() {
  
  return bucket_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetBucketDescriptorRequest::release_bucket_name() {
  // @@protoc_insertion_point(field_release:kvstore.v1.GetBucketDescriptorRequest.bucket_name)
  return bucket_name_.Release();
}
inline void GetBucketDescriptorRequest::set_allocated_bucket_name(std::string* bucket_name) {
  if (bucket_name != nullptr) {
    
  } else {
    
  }
  bucket_name_.SetAllocated(bucket_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bucket_name_.IsDefault()) {
    bucket_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.GetBucketDescriptorRequest.bucket_name)
}

// -------------------------------------------------------------------

// GetBucketDescriptorResponse

// .kvstore.v1.BucketDescriptor bucket_descriptor = 1 [json_name = "bucketDescriptor"];
inline bool GetBucketDescriptorResponse::_internal_has_bucket_descriptor() const {
  return this != internal_default_instance() && bucket_descriptor_ != nullptr;
}
inline bool GetBucketDescriptorResponse::has_bucket_descriptor() const {
  return _internal_has_bucket_descriptor();
}
inline void GetBucketDescriptorResponse::clear_bucket_descriptor() {
  if (GetArenaForAllocation() == nullptr && bucket_descriptor_ != nullptr) {
    delete bucket_descriptor_;
  }
  bucket_descriptor_ = nullptr;
}
inline const ::kvstore::v1::BucketDescriptor& GetBucketDescriptorResponse::_internal_bucket_descriptor() const {
  const ::kvstore::v1::BucketDescriptor* p = bucket_descriptor_;
  return p != nullptr ? *p : reinterpret_cast<const ::kvstore::v1::BucketDescriptor&>(
      ::kvstore::v1::_BucketDescriptor_default_instance_);
}
inline const ::kvstore::v1::BucketDescriptor& GetBucketDescriptorResponse::bucket_descriptor() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.GetBucketDescriptorResponse.bucket_descriptor)
  return _internal_bucket_descriptor();
}
inline void GetBucketDescriptorResponse::unsafe_arena_set_allocated_bucket_descriptor(
    ::kvstore::v1::BucketDescriptor* bucket_descriptor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bucket_descriptor_);
  }
  bucket_descriptor_ = bucket_descriptor;
  if (bucket_descriptor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.GetBucketDescriptorResponse.bucket_descriptor)
}
inline ::kvstore::v1::BucketDescriptor* GetBucketDescriptorResponse::release_bucket_descriptor() {
  
  ::kvstore::v1::BucketDescriptor* temp = bucket_descriptor_;
  bucket_descriptor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kvstore::v1::BucketDescriptor* GetBucketDescriptorResponse::unsafe_arena_release_bucket_descriptor() {
  // @@protoc_insertion_point(field_release:kvstore.v1.GetBucketDescriptorResponse.bucket_descriptor)
  
  ::kvstore::v1::BucketDescriptor* temp = bucket_descriptor_;
  bucket_descriptor_ = nullptr;
  return temp;
}
inline ::kvstore::v1::BucketDescriptor* GetBucketDescriptorResponse::_internal_mutable_bucket_descriptor() {
  
  if (bucket_descriptor_ == nullptr) {
    auto* p = CreateMaybeMessage<::kvstore::v1::BucketDescriptor>(GetArenaForAllocation());
    bucket_descriptor_ = p;
  }
  return bucket_descriptor_;
}
inline ::kvstore::v1::BucketDescriptor* GetBucketDescriptorResponse::mutable_bucket_descriptor() {
  ::kvstore::v1::BucketDescriptor* _msg = _internal_mutable_bucket_descriptor();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.GetBucketDescriptorResponse.bucket_descriptor)
  return _msg;
}
inline void GetBucketDescriptorResponse::set_allocated_bucket_descriptor(::kvstore::v1::BucketDescriptor* bucket_descriptor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bucket_descriptor_;
  }
  if (bucket_descriptor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bucket_descriptor);
    if (message_arena != submessage_arena) {
      bucket_descriptor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bucket_descriptor, submessage_arena);
    }
    
  } else {
    
  }
  bucket_descriptor_ = bucket_descriptor;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.GetBucketDescriptorResponse.bucket_descriptor)
}

// -------------------------------------------------------------------

// GetKeyRequest

// uint64 account_id = 1 [json_name = "accountId"];
inline void GetKeyRequest::clear_account_id() {
  account_id_ = uint64_t{0u};
}
inline uint64_t GetKeyRequest::_internal_account_id() const {
  return account_id_;
}
inline uint64_t GetKeyRequest::account_id() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.GetKeyRequest.account_id)
  return _internal_account_id();
}
inline void GetKeyRequest::_internal_set_account_id(uint64_t value) {
  
  account_id_ = value;
}
inline void GetKeyRequest::set_account_id(uint64_t value) {
  _internal_set_account_id(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.GetKeyRequest.account_id)
}

// string bucket_name = 2 [json_name = "bucketName"];
inline void GetKeyRequest::clear_bucket_name() {
  bucket_name_.ClearToEmpty();
}
inline const std::string& GetKeyRequest::bucket_name() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.GetKeyRequest.bucket_name)
  return _internal_bucket_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetKeyRequest::set_bucket_name(ArgT0&& arg0, ArgT... args) {
 
 bucket_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kvstore.v1.GetKeyRequest.bucket_name)
}
inline std::string* GetKeyRequest::mutable_bucket_name() {
  std::string* _s = _internal_mutable_bucket_name();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.GetKeyRequest.bucket_name)
  return _s;
}
inline const std::string& GetKeyRequest::_internal_bucket_name() const {
  return bucket_name_.Get();
}
inline void GetKeyRequest::_internal_set_bucket_name(const std::string& value) {
  
  bucket_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetKeyRequest::_internal_mutable_bucket_name() {
  
  return bucket_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetKeyRequest::release_bucket_name() {
  // @@protoc_insertion_point(field_release:kvstore.v1.GetKeyRequest.bucket_name)
  return bucket_name_.Release();
}
inline void GetKeyRequest::set_allocated_bucket_name(std::string* bucket_name) {
  if (bucket_name != nullptr) {
    
  } else {
    
  }
  bucket_name_.SetAllocated(bucket_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bucket_name_.IsDefault()) {
    bucket_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.GetKeyRequest.bucket_name)
}

// bytes key = 3 [json_name = "key"];
inline void GetKeyRequest::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& GetKeyRequest::key() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.GetKeyRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetKeyRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kvstore.v1.GetKeyRequest.key)
}
inline std::string* GetKeyRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.GetKeyRequest.key)
  return _s;
}
inline const std::string& GetKeyRequest::_internal_key() const {
  return key_.Get();
}
inline void GetKeyRequest::_internal_set_key(const std::string& value) {
  
  key_.Set(value, GetArenaForAllocation());
}
inline std::string* GetKeyRequest::_internal_mutable_key() {
  
  return key_.Mutable(GetArenaForAllocation());
}
inline std::string* GetKeyRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvstore.v1.GetKeyRequest.key)
  return key_.Release();
}
inline void GetKeyRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.GetKeyRequest.key)
}

// optional uint32 version = 4 [json_name = "version"];
inline bool GetKeyRequest::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetKeyRequest::has_version() const {
  return _internal_has_version();
}
inline void GetKeyRequest::clear_version() {
  version_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t GetKeyRequest::_internal_version() const {
  return version_;
}
inline uint32_t GetKeyRequest::version() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.GetKeyRequest.version)
  return _internal_version();
}
inline void GetKeyRequest::_internal_set_version(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  version_ = value;
}
inline void GetKeyRequest::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.GetKeyRequest.version)
}

// -------------------------------------------------------------------

// GetKeyResponse

// .kvstore.v1.KeyValue key_value_pair = 1 [json_name = "keyValuePair"];
inline bool GetKeyResponse::_internal_has_key_value_pair() const {
  return this != internal_default_instance() && key_value_pair_ != nullptr;
}
inline bool GetKeyResponse::has_key_value_pair() const {
  return _internal_has_key_value_pair();
}
inline void GetKeyResponse::clear_key_value_pair() {
  if (GetArenaForAllocation() == nullptr && key_value_pair_ != nullptr) {
    delete key_value_pair_;
  }
  key_value_pair_ = nullptr;
}
inline const ::kvstore::v1::KeyValue& GetKeyResponse::_internal_key_value_pair() const {
  const ::kvstore::v1::KeyValue* p = key_value_pair_;
  return p != nullptr ? *p : reinterpret_cast<const ::kvstore::v1::KeyValue&>(
      ::kvstore::v1::_KeyValue_default_instance_);
}
inline const ::kvstore::v1::KeyValue& GetKeyResponse::key_value_pair() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.GetKeyResponse.key_value_pair)
  return _internal_key_value_pair();
}
inline void GetKeyResponse::unsafe_arena_set_allocated_key_value_pair(
    ::kvstore::v1::KeyValue* key_value_pair) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_value_pair_);
  }
  key_value_pair_ = key_value_pair;
  if (key_value_pair) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.GetKeyResponse.key_value_pair)
}
inline ::kvstore::v1::KeyValue* GetKeyResponse::release_key_value_pair() {
  
  ::kvstore::v1::KeyValue* temp = key_value_pair_;
  key_value_pair_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kvstore::v1::KeyValue* GetKeyResponse::unsafe_arena_release_key_value_pair() {
  // @@protoc_insertion_point(field_release:kvstore.v1.GetKeyResponse.key_value_pair)
  
  ::kvstore::v1::KeyValue* temp = key_value_pair_;
  key_value_pair_ = nullptr;
  return temp;
}
inline ::kvstore::v1::KeyValue* GetKeyResponse::_internal_mutable_key_value_pair() {
  
  if (key_value_pair_ == nullptr) {
    auto* p = CreateMaybeMessage<::kvstore::v1::KeyValue>(GetArenaForAllocation());
    key_value_pair_ = p;
  }
  return key_value_pair_;
}
inline ::kvstore::v1::KeyValue* GetKeyResponse::mutable_key_value_pair() {
  ::kvstore::v1::KeyValue* _msg = _internal_mutable_key_value_pair();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.GetKeyResponse.key_value_pair)
  return _msg;
}
inline void GetKeyResponse::set_allocated_key_value_pair(::kvstore::v1::KeyValue* key_value_pair) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete key_value_pair_;
  }
  if (key_value_pair) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key_value_pair);
    if (message_arena != submessage_arena) {
      key_value_pair = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key_value_pair, submessage_arena);
    }
    
  } else {
    
  }
  key_value_pair_ = key_value_pair;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.GetKeyResponse.key_value_pair)
}

// -------------------------------------------------------------------

// PutKeyRequest

// uint64 account_id = 1 [json_name = "accountId"];
inline void PutKeyRequest::clear_account_id() {
  account_id_ = uint64_t{0u};
}
inline uint64_t PutKeyRequest::_internal_account_id() const {
  return account_id_;
}
inline uint64_t PutKeyRequest::account_id() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.PutKeyRequest.account_id)
  return _internal_account_id();
}
inline void PutKeyRequest::_internal_set_account_id(uint64_t value) {
  
  account_id_ = value;
}
inline void PutKeyRequest::set_account_id(uint64_t value) {
  _internal_set_account_id(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.PutKeyRequest.account_id)
}

// string bucket_name = 2 [json_name = "bucketName"];
inline void PutKeyRequest::clear_bucket_name() {
  bucket_name_.ClearToEmpty();
}
inline const std::string& PutKeyRequest::bucket_name() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.PutKeyRequest.bucket_name)
  return _internal_bucket_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutKeyRequest::set_bucket_name(ArgT0&& arg0, ArgT... args) {
 
 bucket_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kvstore.v1.PutKeyRequest.bucket_name)
}
inline std::string* PutKeyRequest::mutable_bucket_name() {
  std::string* _s = _internal_mutable_bucket_name();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.PutKeyRequest.bucket_name)
  return _s;
}
inline const std::string& PutKeyRequest::_internal_bucket_name() const {
  return bucket_name_.Get();
}
inline void PutKeyRequest::_internal_set_bucket_name(const std::string& value) {
  
  bucket_name_.Set(value, GetArenaForAllocation());
}
inline std::string* PutKeyRequest::_internal_mutable_bucket_name() {
  
  return bucket_name_.Mutable(GetArenaForAllocation());
}
inline std::string* PutKeyRequest::release_bucket_name() {
  // @@protoc_insertion_point(field_release:kvstore.v1.PutKeyRequest.bucket_name)
  return bucket_name_.Release();
}
inline void PutKeyRequest::set_allocated_bucket_name(std::string* bucket_name) {
  if (bucket_name != nullptr) {
    
  } else {
    
  }
  bucket_name_.SetAllocated(bucket_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bucket_name_.IsDefault()) {
    bucket_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.PutKeyRequest.bucket_name)
}

// .kvstore.v1.KeyValue key_value_pair = 3 [json_name = "keyValuePair"];
inline bool PutKeyRequest::_internal_has_key_value_pair() const {
  return this != internal_default_instance() && key_value_pair_ != nullptr;
}
inline bool PutKeyRequest::has_key_value_pair() const {
  return _internal_has_key_value_pair();
}
inline void PutKeyRequest::clear_key_value_pair() {
  if (GetArenaForAllocation() == nullptr && key_value_pair_ != nullptr) {
    delete key_value_pair_;
  }
  key_value_pair_ = nullptr;
}
inline const ::kvstore::v1::KeyValue& PutKeyRequest::_internal_key_value_pair() const {
  const ::kvstore::v1::KeyValue* p = key_value_pair_;
  return p != nullptr ? *p : reinterpret_cast<const ::kvstore::v1::KeyValue&>(
      ::kvstore::v1::_KeyValue_default_instance_);
}
inline const ::kvstore::v1::KeyValue& PutKeyRequest::key_value_pair() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.PutKeyRequest.key_value_pair)
  return _internal_key_value_pair();
}
inline void PutKeyRequest::unsafe_arena_set_allocated_key_value_pair(
    ::kvstore::v1::KeyValue* key_value_pair) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_value_pair_);
  }
  key_value_pair_ = key_value_pair;
  if (key_value_pair) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.PutKeyRequest.key_value_pair)
}
inline ::kvstore::v1::KeyValue* PutKeyRequest::release_key_value_pair() {
  
  ::kvstore::v1::KeyValue* temp = key_value_pair_;
  key_value_pair_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kvstore::v1::KeyValue* PutKeyRequest::unsafe_arena_release_key_value_pair() {
  // @@protoc_insertion_point(field_release:kvstore.v1.PutKeyRequest.key_value_pair)
  
  ::kvstore::v1::KeyValue* temp = key_value_pair_;
  key_value_pair_ = nullptr;
  return temp;
}
inline ::kvstore::v1::KeyValue* PutKeyRequest::_internal_mutable_key_value_pair() {
  
  if (key_value_pair_ == nullptr) {
    auto* p = CreateMaybeMessage<::kvstore::v1::KeyValue>(GetArenaForAllocation());
    key_value_pair_ = p;
  }
  return key_value_pair_;
}
inline ::kvstore::v1::KeyValue* PutKeyRequest::mutable_key_value_pair() {
  ::kvstore::v1::KeyValue* _msg = _internal_mutable_key_value_pair();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.PutKeyRequest.key_value_pair)
  return _msg;
}
inline void PutKeyRequest::set_allocated_key_value_pair(::kvstore::v1::KeyValue* key_value_pair) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete key_value_pair_;
  }
  if (key_value_pair) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key_value_pair);
    if (message_arena != submessage_arena) {
      key_value_pair = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key_value_pair, submessage_arena);
    }
    
  } else {
    
  }
  key_value_pair_ = key_value_pair;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.PutKeyRequest.key_value_pair)
}

// .kvstore.v1.Transaction transaction = 4 [json_name = "transaction"];
inline bool PutKeyRequest::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool PutKeyRequest::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::kvstore::v1::Transaction& PutKeyRequest::_internal_transaction() const {
  const ::kvstore::v1::Transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::kvstore::v1::Transaction&>(
      ::kvstore::v1::_Transaction_default_instance_);
}
inline const ::kvstore::v1::Transaction& PutKeyRequest::transaction() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.PutKeyRequest.transaction)
  return _internal_transaction();
}
inline void PutKeyRequest::unsafe_arena_set_allocated_transaction(
    ::kvstore::v1::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.PutKeyRequest.transaction)
}
inline ::kvstore::v1::Transaction* PutKeyRequest::release_transaction() {
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kvstore::v1::Transaction* PutKeyRequest::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:kvstore.v1.PutKeyRequest.transaction)
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::kvstore::v1::Transaction* PutKeyRequest::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::kvstore::v1::Transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::kvstore::v1::Transaction* PutKeyRequest::mutable_transaction() {
  ::kvstore::v1::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.PutKeyRequest.transaction)
  return _msg;
}
inline void PutKeyRequest::set_allocated_transaction(::kvstore::v1::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.PutKeyRequest.transaction)
}

// -------------------------------------------------------------------

// PutKeyResponse

// .kvstore.v1.Transaction transaction = 1 [json_name = "transaction"];
inline bool PutKeyResponse::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool PutKeyResponse::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::kvstore::v1::Transaction& PutKeyResponse::_internal_transaction() const {
  const ::kvstore::v1::Transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::kvstore::v1::Transaction&>(
      ::kvstore::v1::_Transaction_default_instance_);
}
inline const ::kvstore::v1::Transaction& PutKeyResponse::transaction() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.PutKeyResponse.transaction)
  return _internal_transaction();
}
inline void PutKeyResponse::unsafe_arena_set_allocated_transaction(
    ::kvstore::v1::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.PutKeyResponse.transaction)
}
inline ::kvstore::v1::Transaction* PutKeyResponse::release_transaction() {
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kvstore::v1::Transaction* PutKeyResponse::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:kvstore.v1.PutKeyResponse.transaction)
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::kvstore::v1::Transaction* PutKeyResponse::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::kvstore::v1::Transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::kvstore::v1::Transaction* PutKeyResponse::mutable_transaction() {
  ::kvstore::v1::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.PutKeyResponse.transaction)
  return _msg;
}
inline void PutKeyResponse::set_allocated_transaction(::kvstore::v1::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.PutKeyResponse.transaction)
}

// -------------------------------------------------------------------

// DeleteKeyRequest

// uint64 account_id = 1 [json_name = "accountId"];
inline void DeleteKeyRequest::clear_account_id() {
  account_id_ = uint64_t{0u};
}
inline uint64_t DeleteKeyRequest::_internal_account_id() const {
  return account_id_;
}
inline uint64_t DeleteKeyRequest::account_id() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.DeleteKeyRequest.account_id)
  return _internal_account_id();
}
inline void DeleteKeyRequest::_internal_set_account_id(uint64_t value) {
  
  account_id_ = value;
}
inline void DeleteKeyRequest::set_account_id(uint64_t value) {
  _internal_set_account_id(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.DeleteKeyRequest.account_id)
}

// string bucket_name = 2 [json_name = "bucketName"];
inline void DeleteKeyRequest::clear_bucket_name() {
  bucket_name_.ClearToEmpty();
}
inline const std::string& DeleteKeyRequest::bucket_name() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.DeleteKeyRequest.bucket_name)
  return _internal_bucket_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteKeyRequest::set_bucket_name(ArgT0&& arg0, ArgT... args) {
 
 bucket_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kvstore.v1.DeleteKeyRequest.bucket_name)
}
inline std::string* DeleteKeyRequest::mutable_bucket_name() {
  std::string* _s = _internal_mutable_bucket_name();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.DeleteKeyRequest.bucket_name)
  return _s;
}
inline const std::string& DeleteKeyRequest::_internal_bucket_name() const {
  return bucket_name_.Get();
}
inline void DeleteKeyRequest::_internal_set_bucket_name(const std::string& value) {
  
  bucket_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteKeyRequest::_internal_mutable_bucket_name() {
  
  return bucket_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteKeyRequest::release_bucket_name() {
  // @@protoc_insertion_point(field_release:kvstore.v1.DeleteKeyRequest.bucket_name)
  return bucket_name_.Release();
}
inline void DeleteKeyRequest::set_allocated_bucket_name(std::string* bucket_name) {
  if (bucket_name != nullptr) {
    
  } else {
    
  }
  bucket_name_.SetAllocated(bucket_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bucket_name_.IsDefault()) {
    bucket_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.DeleteKeyRequest.bucket_name)
}

// bytes key = 3 [json_name = "key"];
inline void DeleteKeyRequest::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& DeleteKeyRequest::key() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.DeleteKeyRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteKeyRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kvstore.v1.DeleteKeyRequest.key)
}
inline std::string* DeleteKeyRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.DeleteKeyRequest.key)
  return _s;
}
inline const std::string& DeleteKeyRequest::_internal_key() const {
  return key_.Get();
}
inline void DeleteKeyRequest::_internal_set_key(const std::string& value) {
  
  key_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteKeyRequest::_internal_mutable_key() {
  
  return key_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteKeyRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvstore.v1.DeleteKeyRequest.key)
  return key_.Release();
}
inline void DeleteKeyRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.DeleteKeyRequest.key)
}

// .kvstore.v1.Transaction transaction = 4 [json_name = "transaction"];
inline bool DeleteKeyRequest::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool DeleteKeyRequest::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::kvstore::v1::Transaction& DeleteKeyRequest::_internal_transaction() const {
  const ::kvstore::v1::Transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::kvstore::v1::Transaction&>(
      ::kvstore::v1::_Transaction_default_instance_);
}
inline const ::kvstore::v1::Transaction& DeleteKeyRequest::transaction() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.DeleteKeyRequest.transaction)
  return _internal_transaction();
}
inline void DeleteKeyRequest::unsafe_arena_set_allocated_transaction(
    ::kvstore::v1::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.DeleteKeyRequest.transaction)
}
inline ::kvstore::v1::Transaction* DeleteKeyRequest::release_transaction() {
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kvstore::v1::Transaction* DeleteKeyRequest::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:kvstore.v1.DeleteKeyRequest.transaction)
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::kvstore::v1::Transaction* DeleteKeyRequest::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::kvstore::v1::Transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::kvstore::v1::Transaction* DeleteKeyRequest::mutable_transaction() {
  ::kvstore::v1::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.DeleteKeyRequest.transaction)
  return _msg;
}
inline void DeleteKeyRequest::set_allocated_transaction(::kvstore::v1::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.DeleteKeyRequest.transaction)
}

// -------------------------------------------------------------------

// DeleteKeyResponse

// bool ok = 1 [json_name = "ok"];
inline void DeleteKeyResponse::clear_ok() {
  ok_ = false;
}
inline bool DeleteKeyResponse::_internal_ok() const {
  return ok_;
}
inline bool DeleteKeyResponse::ok() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.DeleteKeyResponse.ok)
  return _internal_ok();
}
inline void DeleteKeyResponse::_internal_set_ok(bool value) {
  
  ok_ = value;
}
inline void DeleteKeyResponse::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.DeleteKeyResponse.ok)
}

// .kvstore.v1.Transaction transaction = 3 [json_name = "transaction"];
inline bool DeleteKeyResponse::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool DeleteKeyResponse::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::kvstore::v1::Transaction& DeleteKeyResponse::_internal_transaction() const {
  const ::kvstore::v1::Transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::kvstore::v1::Transaction&>(
      ::kvstore::v1::_Transaction_default_instance_);
}
inline const ::kvstore::v1::Transaction& DeleteKeyResponse::transaction() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.DeleteKeyResponse.transaction)
  return _internal_transaction();
}
inline void DeleteKeyResponse::unsafe_arena_set_allocated_transaction(
    ::kvstore::v1::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.DeleteKeyResponse.transaction)
}
inline ::kvstore::v1::Transaction* DeleteKeyResponse::release_transaction() {
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kvstore::v1::Transaction* DeleteKeyResponse::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:kvstore.v1.DeleteKeyResponse.transaction)
  
  ::kvstore::v1::Transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::kvstore::v1::Transaction* DeleteKeyResponse::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::kvstore::v1::Transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::kvstore::v1::Transaction* DeleteKeyResponse::mutable_transaction() {
  ::kvstore::v1::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.DeleteKeyResponse.transaction)
  return _msg;
}
inline void DeleteKeyResponse::set_allocated_transaction(::kvstore::v1::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.DeleteKeyResponse.transaction)
}

// -------------------------------------------------------------------

// KeyValueDescriptor

// repeated uint32 versions = 1 [json_name = "versions"];
inline int KeyValueDescriptor::_internal_versions_size() const {
  return versions_.size();
}
inline int KeyValueDescriptor::versions_size() const {
  return _internal_versions_size();
}
inline void KeyValueDescriptor::clear_versions() {
  versions_.Clear();
}
inline uint32_t KeyValueDescriptor::_internal_versions(int index) const {
  return versions_.Get(index);
}
inline uint32_t KeyValueDescriptor::versions(int index) const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KeyValueDescriptor.versions)
  return _internal_versions(index);
}
inline void KeyValueDescriptor::set_versions(int index, uint32_t value) {
  versions_.Set(index, value);
  // @@protoc_insertion_point(field_set:kvstore.v1.KeyValueDescriptor.versions)
}
inline void KeyValueDescriptor::_internal_add_versions(uint32_t value) {
  versions_.Add(value);
}
inline void KeyValueDescriptor::add_versions(uint32_t value) {
  _internal_add_versions(value);
  // @@protoc_insertion_point(field_add:kvstore.v1.KeyValueDescriptor.versions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
KeyValueDescriptor::_internal_versions() const {
  return versions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
KeyValueDescriptor::versions() const {
  // @@protoc_insertion_point(field_list:kvstore.v1.KeyValueDescriptor.versions)
  return _internal_versions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
KeyValueDescriptor::_internal_mutable_versions() {
  return &versions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
KeyValueDescriptor::mutable_versions() {
  // @@protoc_insertion_point(field_mutable_list:kvstore.v1.KeyValueDescriptor.versions)
  return _internal_mutable_versions();
}

// bytes current_key = 2 [json_name = "currentKey"];
inline void KeyValueDescriptor::clear_current_key() {
  current_key_.ClearToEmpty();
}
inline const std::string& KeyValueDescriptor::current_key() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KeyValueDescriptor.current_key)
  return _internal_current_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyValueDescriptor::set_current_key(ArgT0&& arg0, ArgT... args) {
 
 current_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kvstore.v1.KeyValueDescriptor.current_key)
}
inline std::string* KeyValueDescriptor::mutable_current_key() {
  std::string* _s = _internal_mutable_current_key();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.KeyValueDescriptor.current_key)
  return _s;
}
inline const std::string& KeyValueDescriptor::_internal_current_key() const {
  return current_key_.Get();
}
inline void KeyValueDescriptor::_internal_set_current_key(const std::string& value) {
  
  current_key_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyValueDescriptor::_internal_mutable_current_key() {
  
  return current_key_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyValueDescriptor::release_current_key() {
  // @@protoc_insertion_point(field_release:kvstore.v1.KeyValueDescriptor.current_key)
  return current_key_.Release();
}
inline void KeyValueDescriptor::set_allocated_current_key(std::string* current_key) {
  if (current_key != nullptr) {
    
  } else {
    
  }
  current_key_.SetAllocated(current_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (current_key_.IsDefault()) {
    current_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.KeyValueDescriptor.current_key)
}

// -------------------------------------------------------------------

// ListKeyVersionsRequest

// bytes key = 1 [json_name = "key"];
inline void ListKeyVersionsRequest::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& ListKeyVersionsRequest::key() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.ListKeyVersionsRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListKeyVersionsRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kvstore.v1.ListKeyVersionsRequest.key)
}
inline std::string* ListKeyVersionsRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.ListKeyVersionsRequest.key)
  return _s;
}
inline const std::string& ListKeyVersionsRequest::_internal_key() const {
  return key_.Get();
}
inline void ListKeyVersionsRequest::_internal_set_key(const std::string& value) {
  
  key_.Set(value, GetArenaForAllocation());
}
inline std::string* ListKeyVersionsRequest::_internal_mutable_key() {
  
  return key_.Mutable(GetArenaForAllocation());
}
inline std::string* ListKeyVersionsRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvstore.v1.ListKeyVersionsRequest.key)
  return key_.Release();
}
inline void ListKeyVersionsRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.ListKeyVersionsRequest.key)
}

// -------------------------------------------------------------------

// ListKeyVersionsResponse

// repeated uint32 versions = 1 [json_name = "versions"];
inline int ListKeyVersionsResponse::_internal_versions_size() const {
  return versions_.size();
}
inline int ListKeyVersionsResponse::versions_size() const {
  return _internal_versions_size();
}
inline void ListKeyVersionsResponse::clear_versions() {
  versions_.Clear();
}
inline uint32_t ListKeyVersionsResponse::_internal_versions(int index) const {
  return versions_.Get(index);
}
inline uint32_t ListKeyVersionsResponse::versions(int index) const {
  // @@protoc_insertion_point(field_get:kvstore.v1.ListKeyVersionsResponse.versions)
  return _internal_versions(index);
}
inline void ListKeyVersionsResponse::set_versions(int index, uint32_t value) {
  versions_.Set(index, value);
  // @@protoc_insertion_point(field_set:kvstore.v1.ListKeyVersionsResponse.versions)
}
inline void ListKeyVersionsResponse::_internal_add_versions(uint32_t value) {
  versions_.Add(value);
}
inline void ListKeyVersionsResponse::add_versions(uint32_t value) {
  _internal_add_versions(value);
  // @@protoc_insertion_point(field_add:kvstore.v1.ListKeyVersionsResponse.versions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
ListKeyVersionsResponse::_internal_versions() const {
  return versions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
ListKeyVersionsResponse::versions() const {
  // @@protoc_insertion_point(field_list:kvstore.v1.ListKeyVersionsResponse.versions)
  return _internal_versions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
ListKeyVersionsResponse::_internal_mutable_versions() {
  return &versions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
ListKeyVersionsResponse::mutable_versions() {
  // @@protoc_insertion_point(field_mutable_list:kvstore.v1.ListKeyVersionsResponse.versions)
  return _internal_mutable_versions();
}

// -------------------------------------------------------------------

// KeyValue

// bytes key = 1 [json_name = "key"];
inline void KeyValue::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& KeyValue::key() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KeyValue.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyValue::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kvstore.v1.KeyValue.key)
}
inline std::string* KeyValue::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.KeyValue.key)
  return _s;
}
inline const std::string& KeyValue::_internal_key() const {
  return key_.Get();
}
inline void KeyValue::_internal_set_key(const std::string& value) {
  
  key_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyValue::_internal_mutable_key() {
  
  return key_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyValue::release_key() {
  // @@protoc_insertion_point(field_release:kvstore.v1.KeyValue.key)
  return key_.Release();
}
inline void KeyValue::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.KeyValue.key)
}

// int64 create_revision = 2 [json_name = "createRevision"];
inline void KeyValue::clear_create_revision() {
  create_revision_ = int64_t{0};
}
inline int64_t KeyValue::_internal_create_revision() const {
  return create_revision_;
}
inline int64_t KeyValue::create_revision() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KeyValue.create_revision)
  return _internal_create_revision();
}
inline void KeyValue::_internal_set_create_revision(int64_t value) {
  
  create_revision_ = value;
}
inline void KeyValue::set_create_revision(int64_t value) {
  _internal_set_create_revision(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.KeyValue.create_revision)
}

// int64 mod_revision = 3 [json_name = "modRevision"];
inline void KeyValue::clear_mod_revision() {
  mod_revision_ = int64_t{0};
}
inline int64_t KeyValue::_internal_mod_revision() const {
  return mod_revision_;
}
inline int64_t KeyValue::mod_revision() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KeyValue.mod_revision)
  return _internal_mod_revision();
}
inline void KeyValue::_internal_set_mod_revision(int64_t value) {
  
  mod_revision_ = value;
}
inline void KeyValue::set_mod_revision(int64_t value) {
  _internal_set_mod_revision(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.KeyValue.mod_revision)
}

// uint64 version = 4 [json_name = "version"];
inline void KeyValue::clear_version() {
  version_ = uint64_t{0u};
}
inline uint64_t KeyValue::_internal_version() const {
  return version_;
}
inline uint64_t KeyValue::version() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KeyValue.version)
  return _internal_version();
}
inline void KeyValue::_internal_set_version(uint64_t value) {
  
  version_ = value;
}
inline void KeyValue::set_version(uint64_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.KeyValue.version)
}

// bytes value = 5 [json_name = "value"];
inline void KeyValue::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& KeyValue::value() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KeyValue.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyValue::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kvstore.v1.KeyValue.value)
}
inline std::string* KeyValue::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.KeyValue.value)
  return _s;
}
inline const std::string& KeyValue::_internal_value() const {
  return value_.Get();
}
inline void KeyValue::_internal_set_value(const std::string& value) {
  
  value_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyValue::_internal_mutable_value() {
  
  return value_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyValue::release_value() {
  // @@protoc_insertion_point(field_release:kvstore.v1.KeyValue.value)
  return value_.Release();
}
inline void KeyValue::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault()) {
    value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.KeyValue.value)
}

// int64 lease = 6 [json_name = "lease"];
inline void KeyValue::clear_lease() {
  lease_ = int64_t{0};
}
inline int64_t KeyValue::_internal_lease() const {
  return lease_;
}
inline int64_t KeyValue::lease() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.KeyValue.lease)
  return _internal_lease();
}
inline void KeyValue::_internal_set_lease(int64_t value) {
  
  lease_ = value;
}
inline void KeyValue::set_lease(int64_t value) {
  _internal_set_lease(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.KeyValue.lease)
}

// -------------------------------------------------------------------

// Event

// .kvstore.v1.KeyOperationType type = 1 [json_name = "type"];
inline void Event::clear_type() {
  type_ = 0;
}
inline ::kvstore::v1::KeyOperationType Event::_internal_type() const {
  return static_cast< ::kvstore::v1::KeyOperationType >(type_);
}
inline ::kvstore::v1::KeyOperationType Event::type() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.Event.type)
  return _internal_type();
}
inline void Event::_internal_set_type(::kvstore::v1::KeyOperationType value) {
  
  type_ = value;
}
inline void Event::set_type(::kvstore::v1::KeyOperationType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:kvstore.v1.Event.type)
}

// .kvstore.v1.KeyValue kv = 2 [json_name = "kv"];
inline bool Event::_internal_has_kv() const {
  return this != internal_default_instance() && kv_ != nullptr;
}
inline bool Event::has_kv() const {
  return _internal_has_kv();
}
inline void Event::clear_kv() {
  if (GetArenaForAllocation() == nullptr && kv_ != nullptr) {
    delete kv_;
  }
  kv_ = nullptr;
}
inline const ::kvstore::v1::KeyValue& Event::_internal_kv() const {
  const ::kvstore::v1::KeyValue* p = kv_;
  return p != nullptr ? *p : reinterpret_cast<const ::kvstore::v1::KeyValue&>(
      ::kvstore::v1::_KeyValue_default_instance_);
}
inline const ::kvstore::v1::KeyValue& Event::kv() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.Event.kv)
  return _internal_kv();
}
inline void Event::unsafe_arena_set_allocated_kv(
    ::kvstore::v1::KeyValue* kv) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kv_);
  }
  kv_ = kv;
  if (kv) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.Event.kv)
}
inline ::kvstore::v1::KeyValue* Event::release_kv() {
  
  ::kvstore::v1::KeyValue* temp = kv_;
  kv_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kvstore::v1::KeyValue* Event::unsafe_arena_release_kv() {
  // @@protoc_insertion_point(field_release:kvstore.v1.Event.kv)
  
  ::kvstore::v1::KeyValue* temp = kv_;
  kv_ = nullptr;
  return temp;
}
inline ::kvstore::v1::KeyValue* Event::_internal_mutable_kv() {
  
  if (kv_ == nullptr) {
    auto* p = CreateMaybeMessage<::kvstore::v1::KeyValue>(GetArenaForAllocation());
    kv_ = p;
  }
  return kv_;
}
inline ::kvstore::v1::KeyValue* Event::mutable_kv() {
  ::kvstore::v1::KeyValue* _msg = _internal_mutable_kv();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.Event.kv)
  return _msg;
}
inline void Event::set_allocated_kv(::kvstore::v1::KeyValue* kv) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kv_;
  }
  if (kv) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(kv);
    if (message_arena != submessage_arena) {
      kv = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kv, submessage_arena);
    }
    
  } else {
    
  }
  kv_ = kv;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.Event.kv)
}

// optional .kvstore.v1.KeyValue prev_kv = 3 [json_name = "prevKv"];
inline bool Event::_internal_has_prev_kv() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || prev_kv_ != nullptr);
  return value;
}
inline bool Event::has_prev_kv() const {
  return _internal_has_prev_kv();
}
inline void Event::clear_prev_kv() {
  if (prev_kv_ != nullptr) prev_kv_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::kvstore::v1::KeyValue& Event::_internal_prev_kv() const {
  const ::kvstore::v1::KeyValue* p = prev_kv_;
  return p != nullptr ? *p : reinterpret_cast<const ::kvstore::v1::KeyValue&>(
      ::kvstore::v1::_KeyValue_default_instance_);
}
inline const ::kvstore::v1::KeyValue& Event::prev_kv() const {
  // @@protoc_insertion_point(field_get:kvstore.v1.Event.prev_kv)
  return _internal_prev_kv();
}
inline void Event::unsafe_arena_set_allocated_prev_kv(
    ::kvstore::v1::KeyValue* prev_kv) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prev_kv_);
  }
  prev_kv_ = prev_kv;
  if (prev_kv) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kvstore.v1.Event.prev_kv)
}
inline ::kvstore::v1::KeyValue* Event::release_prev_kv() {
  _has_bits_[0] &= ~0x00000001u;
  ::kvstore::v1::KeyValue* temp = prev_kv_;
  prev_kv_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kvstore::v1::KeyValue* Event::unsafe_arena_release_prev_kv() {
  // @@protoc_insertion_point(field_release:kvstore.v1.Event.prev_kv)
  _has_bits_[0] &= ~0x00000001u;
  ::kvstore::v1::KeyValue* temp = prev_kv_;
  prev_kv_ = nullptr;
  return temp;
}
inline ::kvstore::v1::KeyValue* Event::_internal_mutable_prev_kv() {
  _has_bits_[0] |= 0x00000001u;
  if (prev_kv_ == nullptr) {
    auto* p = CreateMaybeMessage<::kvstore::v1::KeyValue>(GetArenaForAllocation());
    prev_kv_ = p;
  }
  return prev_kv_;
}
inline ::kvstore::v1::KeyValue* Event::mutable_prev_kv() {
  ::kvstore::v1::KeyValue* _msg = _internal_mutable_prev_kv();
  // @@protoc_insertion_point(field_mutable:kvstore.v1.Event.prev_kv)
  return _msg;
}
inline void Event::set_allocated_prev_kv(::kvstore::v1::KeyValue* prev_kv) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete prev_kv_;
  }
  if (prev_kv) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(prev_kv);
    if (message_arena != submessage_arena) {
      prev_kv = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prev_kv, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  prev_kv_ = prev_kv;
  // @@protoc_insertion_point(field_set_allocated:kvstore.v1.Event.prev_kv)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace kvstore

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::kvstore::v1::KVStoreWrapper_RequestType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kvstore::v1::KVStoreWrapper_RequestType>() {
  return ::kvstore::v1::KVStoreWrapper_RequestType_descriptor();
}
template <> struct is_proto_enum< ::kvstore::v1::KeyOperationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kvstore::v1::KeyOperationType>() {
  return ::kvstore::v1::KeyOperationType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_kvstore_2fv1_2fkv_2eproto
