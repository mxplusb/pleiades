syntax = "proto3";
package database;

option go_package = "./database";

service RaftClusterService {
  rpc StartCluster(StartClusterRequest) returns (StartClusterResponse);
  rpc StopCluster(StopClusterRequest) returns (StopClusterResponse);
  rpc GetClusterMembership(GetClusterMembershipRequest) returns (GetClusterMembershipResponse);
}

message RaftClusterPayload {
  oneof Type {
      GetClusterMembershipRequest GetClusterMembershipRequest = 1;
      GetClusterMembershipResponse GetClusterMembershipResponse = 2;
      StopClusterRequest StopClusterRequest = 3;
      StopClusterResponse StopClusterResponse = 4;
      StartClusterRequest StartClusterRequest = 5;
      StartClusterResponse StartClusterResponse = 6;
  }
  enum MethodName {
    START_CLUSTER = 0;
    STOP_CLUSTER = 1;
    GET_CLUSTER_MEMBERSHIP = 2;
  }
  MethodName Method = 7;
}

message GetClusterMembershipRequest {
  uint64 clusterId = 1;
}

message GetClusterMembershipResponse {
  RaftMembership membership = 1;
}

// Membership is the struct used to describe Raft cluster membership query
// results.
message RaftMembership {
  // ConfigChangeID is the Raft entry index of the last applied membership
  // change entry.
  uint64 ConfigChangeID = 1;
  // Nodes is a map of NodeID values to NodeHost Raft addresses for all regular
  // Raft nodes.
  map<uint64, string> Nodes = 2;
  // Observers is a map of NodeID values to NodeHost Raft addresses for all
  // observers in the Raft cluster.
  map<uint64, string> Observers = 3;
  // Witnesses is a map of NodeID values to NodeHost Raft addrsses for all
  // witnesses in the Raft cluster.
  map<uint64, string>  Witnesses = 4;
  // Removed is a set of NodeID values that have been removed from the Raft
  // cluster. They are not allowed to be added back to the cluster.
  map<uint64, NilVal>  Removed = 5;
}

message NilVal {}

message StopClusterRequest {
  uint64 clusterId = 1;
}

message StopClusterResponse {}

message StartClusterRequest{
  map<uint64, string> initialMembers = 1;
  bool join = 2;
  RaftConfig raftConfig = 3;
  optional bool concurrent = 4;
  optional bool onDisk = 5;
}

message StartClusterResponse{}

// RaftConfig is used to configure Raft clusters.
message RaftConfig {
  // NodeID is a non-zero value used to identify a node within a Raft cluster.
  uint64 NodeID = 1;
  // ClusterID is the unique value used to identify a Raft cluster.
  uint64  ClusterID = 2;
  // CheckQuorum specifies whether the leader node should periodically check
  // non-leader node status and step down to become a follower node when it no
  // longer has the quorum.
  bool CheckQuorum = 3;
  // ElectionRoundTripTime is the minimum number of message RoundTripTime between elections. Message
  // RoundTripTime is defined by NodeHostConfig.RoundTripTimeMillisecond. The Raft paper suggests it
  // to be a magnitude greater than HeartbeatRoundTripTime, which is the interval between
  // two heartbeats. In Raft, the actual interval between elections is
  // randomized to be between ElectionRoundTripTime and 2 * ElectionRoundTripTime.
  //
  // As an example, assuming NodeHostConfig.RoundTripTimeMillisecond is 100 millisecond,
  // to set the election interval to be 1 second, then ElectionRoundTripTime should be set
  // to 10.
  //
  // When CheckQuorum is enabled, ElectionRoundTripTime also defines the interval for
  // checking leader quorum.
  uint64 ElectionRoundTripTime = 4;
  // HeartbeatRoundTripTime is the number of message RoundTripTime between heartbeats. Message
  // RoundTripTime is defined by NodeHostConfig.RoundTripTimeMillisecond. The Raft paper suggest the
  // heartbeat interval to be close to the average RoundTripTime between nodes.
  //
  // As an example, assuming NodeHostConfig.RoundTripTimeMillisecond is 100 millisecond,
  // to set the heartbeat interval to be every 200 milliseconds, then
  // HeartbeatRoundTripTime should be set to 2.
  uint64 HeartbeatRoundTripTime = 5;
  // SnapshotEntries defines how often the state machine should be snapshot
  // automatically. It is defined in terms of the number of applied Raft log
  // entries. SnapshotEntries can be set to 0 to disable such automatic
  // snapshotting.
  //
  // When SnapshotEntries is set to N, it means a snapshot is created for
  // roughly every N applied Raft log entries (proposals). This also implies
  // that sending N log entries to a follower is more expensive than sending a
  // snapshot.
  //
  // Once a snapshot is generated, Raft log entries covered by the new snapshot
  // can be compacted. This involves two steps, redundant log entries are first
  // marked as deleted, then they are physically removed from the underlying
  // storage when a LogDB compaction is issued at a later stage. See the godoc
  // on CompactionOverhead for details on what log entries are actually removed
  // and compacted after generating a snapshot.
  //
  // Once automatic snapshotting is disabled by setting the SnapshotEntries
  // field to 0, users can still use NodeHost's RequestSnapshot or
  // SyncRequestSnapshot methods to manually request snapshots.
  uint64 SnapshotEntries = 6;
  // CompactionOverhead defines the number of most recent entries to keep after
  // each Raft log compaction. Raft log compaction is performance automatically
  // every time when a snapshot is created.
  //
  // For example, when a snapshot is created at let's say index 10,000, then all
  // Raft log entries with index <= 10,000 can be removed from that node as they
  // have already been covered by the created snapshot image. This frees up the
  // maximum storage space but comes at the cost that the full snapshot will
  // have to be sent to the follower if the follower requires any Raft log entry
  // at index <= 10,000. When CompactionOverhead is set to say 500, Dragonboat
  // then compacts the Raft log up to index 9,500 and keeps Raft log entries
  // between index (9,500, 1,0000]. As a result, the node can still replicate
  // Raft log entries between index (9,500, 1,0000] to other peers and only fall
  // back to stream the full snapshot if any Raft log entry with index <= 9,500
  // is required to be replicated.
  uint64 CompactionOverhead = 7;
  // OrderedConfigChange determines whether Raft membership change is enforced
  // with ordered config change ID.
  bool OrderedConfigChange = 8;
  // MaxInMemLogSize is the target size in bytes allowed for storing in memory
  // Raft logs on each Raft node. In memory Raft logs are the ones that have
  // not been applied yet.
  // MaxInMemLogSize is a target value implemented to prevent unbounded memory
  // growth, it is not for precisely limiting the exact memory usage.
  // When MaxInMemLogSize is 0, the target is set to math.MaxUint64. When
  // MaxInMemLogSize is set and the target is reached, error will be returned
  // when clients try to make new proposals.
  // MaxInMemLogSize is recommended to be significantly larger than the biggest
  // proposal you are going to use.
  uint64 MaxInMemLogSize = 9;
  // SnapshotCompressionType is the compression type to use for compressing
  // generated snapshot data. No compression is used by default.
  int32 SnapshotCompressionType = 10;
  // EntryCompressionType is the compression type to use for compressing the
  // payload of user proposals. When Snappy is used, the maximum proposal
  // payload allowed is roughly limited to 3.42GBytes. No compression is used
  // by default.
  int32 EntryCompressionType = 11;
  // DisableAutoCompactions disables auto compaction used for reclaiming Raft
  // log entry storage spaces. By default, compaction request is issued every
  // time when a snapshot is created, this helps to reclaim disk spaces as
  // soon as possible at the cost of immediate higher IO overhead. Users can
  // disable such auto compactions and use NodeHost.RequestCompaction to
  // manually request such compactions when necessary.
  bool DisableAutoCompactions = 12;
  // IsObserver indicates whether this is an observer Raft node without voting
  // power. Described as non-voting members in the section 4.2.1 of Diego
  // Ongaro's thesis, observer nodes are usually used to allow a new node to
  // join the cluster and catch up with other existing ndoes without impacting
  // the availability. Extra observer nodes can also be introduced to serve
  // read-only requests without affecting system write throughput.
  //
  // Observer support is currently experimental.
  bool IsObserver = 13;
  // IsWitness indicates whether this is a witness Raft node without actual log
  // replication and do not have state machine. It is mentioned in the section
  // 11.7.2 of Diego Ongaro's thesis.
  //
  // Witness support is currently experimental.
  bool IsWitness = 14;
  // Quiesce specifies whether to let the Raft cluster enter quiesce mode when
  // there is no cluster activity. Clusters in quiesce mode do not exchange
  // heartbeat messages to minimize bandwidth consumption.
  //
  // Quiesce support is currently experimental.
  bool Quiesce = 15;
}