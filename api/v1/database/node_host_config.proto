syntax = "proto3";
package database;

option go_package = "./database";

service NodeConfigService {
  rpc GetNodeHostConfig(GetNodeHostConfigRequest) returns (GetNodeHostConfigResponse);
  rpc GetNodeHostInfo(GetNodeHostInfoRequest) returns (GetNodeHostInfoResponse);
  rpc HasNodeInfo(HasNodeInfoRequest) returns (HasNodeInfoResponse);
}

message HasNodeInfoRequest {
  uint64 clusterID = 1;
  uint64 nodeID = 2;
}

message HasNodeInfoResponse {
  bool hasNodeInfo = 1;
}

message GetNodeHostInfoRequest {
  NodeHostInfoOption option = 1;
}

message GetNodeHostInfoResponse {
  NodeHostInfo info = 1;
}

message GetNodeHostConfigRequest {
  optional uint64 clusterID = 1;
  optional uint64 nodeID = 2;
}

message GetNodeHostConfigResponse {
  optional NodeHostConfig nodeHostConfig = 1;
}

// NodeHostConfig is the configuration used to configure NodeHost instances.
message NodeHostConfig {
  // DeploymentID is used to determine whether two NodeHost instances belong to
  // the same deployment and thus allowed to communicate with each other. This
  // helps to prvent accidentially misconfigured NodeHost instances to cause
  // data corruption errors by sending out of context messages to unrelated
  // Raft nodes.
  // For a particular dragonboat based application, you can set DeploymentID
  // to the same uint64 value on all production NodeHost instances, then use
  // different DeploymentID values on your staging and dev environment. It is
  // also recommended to use different DeploymentID values for different
  // dragonboat based applications.
  // When not set, the default value 0 will be used as the deployment ID and
  // thus allowing all NodeHost instances with deployment ID 0 to communicate
  // with each other.
  uint64 DeploymentID = 1;
  // WALDir is the directory used for storing the WAL of Raft entries. It is
  // recommended to use low latency storage such as NVME SSD with power loss
  // protection to store such WAL data. Leave WALDir to have zero value will
  // have everything stored in NodeHostDir.
  string WALDir = 2;
  // NodeHostDir is where everything else is stored.
  string NodeHostDir = 3;
  // RTTMillisecond defines the average Rround Trip Time (RTT) in milliseconds
  // between two NodeHost instances. Such a RTT interval is internally used as
  // a logical clock tick, Raft heartbeat and election intervals are both
  // defined in term of how many such logical clock ticks (RTT intervals).
  // Note that RTTMillisecond is the combined delays between two NodeHost
  // instances including all delays caused by network transmission, delays
  // caused by NodeHost queuing and processing. As an example, when fully
  // loaded, the average Rround Trip Time between two of our NodeHost instances
  // used for benchmarking purposes is up to 500 microseconds when the ping time
  // between them is 100 microseconds. Set RTTMillisecond to 1 when it is less
  // than 1 million in your environment.
  uint64 RoundTripTimeMillisecond = 4;
  // RaftAddress is a DNS name:port or IP:port address used by the transport
  // module for exchanging Raft messages, snapshots and metadata between
  // NodeHost instances. It should be set to the public address that can be
  // accessed from remote NodeHost instances.
  //
  // When the NodeHostConfig.ListenAddress field is empty, NodeHost listens on
  // RaftAddress for incoming Raft messages. When hostname or domain name is
  // used, it will be resolved to IPv4 addresses first and Dragonboat listens
  // to all resolved IPv4 addresses.
  //
  // By default, the RaftAddress value is not allowed to change between NodeHost
  // restarts. AddressByNodeHostID should be set to true when the RaftAddress
  // value might change after restart.
  string RaftAddress = 5;
  // AddressByNodeHostID indicates that NodeHost instances should be addressed
  // by their NodeHostID values. This feature is usually used when only dynamic
  // addresses are available. When enabled, NodeHostID values should be used
  // as the target parameter when calling NodeHost's StartCluster,
  // RequestAddNode, RequestAddObserver and RequestAddWitness methods.
  //
  // Enabling AddressByNodeHostID also enables the internal gossip service,
  // NodeHostConfig.Gossip must be configured to control the behaviors of the
  // gossip service.
  //
  // Note that once enabled, the AddressByNodeHostID setting can not be later
  // disabled after restarts.
  //
  // Please see the godocs of the NodeHostConfig.Gossip field for a detailed
  // example on how AddressByNodeHostID and gossip works.
  bool AddressByNodeHostID = 6;
  // ListenAddress is an optional field in the hostname:port or IP:port address
  // form used by the transport module to listen on for Raft message and
  // snapshots. When the ListenAddress field is not set, The transport module
  // listens on RaftAddress. If 0.0.0.0 is specified as the IP of the
  // ListenAddress, Dragonboat listens to the specified port on all network
  // interfaces. When hostname or domain name is used, it will be resolved to
  // IPv4 addresses first and Dragonboat listens to all resolved IPv4 addresses.
  string ListenAddress = 7;
  // MutualTLS defines whether to use mutual TLS for authenticating servers
  // and clients. Insecure communication is used when MutualTLS is set to
  // False.
  // See https://github.com/lni/dragonboat/wiki/TLS-in-Dragonboat for more
  // details on how to use Mutual TLS.
  bool MutualTLS = 8;
  // CAFile is the path of the CA certificate file. This field is ignored when
  // MutualTLS is false.
  string CAFile = 9;
  // CertFile is the path of the node certificate file. This field is ignored
  // when MutualTLS is false.
  string CertFile = 10;
  // KeyFile is the path of the node key file. This field is ignored when
  // MutualTLS is false.
  string KeyFile = 11;
  // EnableMetrics determines whether health metrics in Prometheus format should
  // be enabled.
  bool EnableMetrics = 12;
  // MaxSendQueueSize is the maximum size in bytes of each send queue.
  // Once the maximum size is reached, further replication messages will be
  // dropped to restrict memory usage. When set to 0, it means the send queue
  // size is unlimited.
  uint64  MaxSendQueueSize = 13;
  // MaxReceiveQueueSize is the maximum size in bytes of each receive queue.
  // Once the maximum size is reached, further replication messages will be
  // dropped to restrict memory usage. When set to 0, it means the queue size
  // is unlimited.
  uint64   MaxReceiveQueueSize = 14;
  // MaxSnapshotSendBytesPerSecond defines how much snapshot data can be sent
  // every second for all Raft clusters managed by the NodeHost instance.
  // The default value 0 means there is no limit set for snapshot streaming.
  uint64   MaxSnapshotSendBytesPerSecond = 15;
  // MaxSnapshotRecvBytesPerSecond defines how much snapshot data can be
  // received each second for all Raft clusters managed by the NodeHost instance.
  // The default value 0 means there is no limit for receiving snapshot data.
  uint64  MaxSnapshotRecvBytesPerSecond = 16;
  // NotifyCommit specifies whether clients should be notified when their
  // regular proposals and config change requests are committed. By default,
  // commits are not notified, clients are only notified when their proposals
  // are both committed and applied.
  bool  NotifyCommit = 17;
  // Gossip contains configurations for the gossip service. When the
  // AddressByNodeHostID field is set to true, each NodeHost instance will use
  // an internal gossip service to exchange knowledges of known NodeHost
  // instances including their RaftAddress and NodeHostID values. This Gossip
  // field contains configurations that controls how the gossip service works.
  //
  // As an detailed example on how to use the gossip service in the situation
  // where all available machines have dynamically assigned IPs on reboot -
  //
  // Consider that there are three NodeHost instances on three machines, each
  // of them has a dynamically assigned IP address which will change on reboot.
  // NodeHostConfig.RaftAddress should be set to the current address that can be
  // reached by remote NodeHost instance. In this example, we will assume they
  // are
  //
  // 10.0.0.100:24000
  // 10.0.0.200:24000
  // 10.0.0.300:24000
  //
  // To use these machines, first enable the NodeHostConfig.AddressByNodeHostID
  // field and start the NodeHost instances. The NodeHostID value of each
  // NodeHost instance can be obtained by calling NodeHost.ID(). Let's say they
  // are
  //
  // "nhid-xxxxx",
  // "nhid-yyyyy",
  // "nhid-zzzzz".
  //
  // All these NodeHostID are fixed, they will never change after reboots.
  //
  // When starting Raft nodes or requesting new nodes to be added, use the above
  // mentioned NodeHostID values as the target parameters (which are of the
  // Target type). Let's say we want to start a Raft Node as a part of a three
  // replicas Raft cluster, the initialMembers parameter of the StartCluster
  // method can be set to
  //
  // initialMembers := map[uint64]Target {
  // 	 1: "nhid-xxxxx",
  //   2: "nhid-yyyyy",
  //   3: "nhid-zzzzz",
  // }
  //
  // This indicates that node 1 of the cluster will be running on the NodeHost
  // instance identified by the NodeHostID value "nhid-xxxxx", node 2 of the
  // same cluster will be running on the NodeHost instance identified by the
  // NodeHostID value of "nhid-yyyyy" and so on.
  //
  // The internal gossip service exchanges NodeHost details, including their
  // NodeHostID and RaftAddress values, with all other known NodeHost instances.
  // Thanks to the nature of gossip, it will eventually allow each NodeHost
  // instance to be aware of the current details of all NodeHost instances.
  // As a result, let's say when Raft node 1 wants to send a Raft message to
  // node 2, it first figures out that node 2 is running on the NodeHost
  // identified by the NodeHostID value "nhid-yyyyy", RaftAddress information
  // from the gossip service further shows that "nhid-yyyyy" maps to a machine
  // currently reachable at 10.0.0.200:24000. Raft messages can thus be
  // delivered.
  //
  // The Gossip field here is used to configure how the gossip service works.
  // In this example, let's say we choose to use the following configurations
  // for those three NodeHost instaces.
  //
  // GossipConfig {
  //   BindAddress: "10.0.0.100:24001",
  //   Seed: []string{10.0.0.200:24001},
  // }
  //
  // GossipConfig {
  //   BindAddress: "10.0.0.200:24001",
  //   Seed: []string{10.0.0.300:24001},
  // }
  //
  // GossipConfig {
  //   BindAddress: "10.0.0.300:24001",
  //   Seed: []string{10.0.0.100:24001},
  // }
  //
  // For those three machines, the gossip component listens on
  // "10.0.0.100:24001", "10.0.0.200:24001" and "10.0.0.300:24001" respectively
  // for incoming gossip messages. The Seed field is a list of known gossip end
  // points the local gossip service will try to talk to. The Seed field doesn't
  // need to include all gossip end points, a few well connected nodes in the
  // gossip network is enough.
  GossipConfig GossipConfig = 18;
}

// GossipConfig contains configurations for the gossip service. Gossip service
// is a fully distributed networked service for exchanging knowledges on
// NodeHost instances. When enabled by the NodeHostConfig.AddressByNodeHostID
// field, it is employed to manage NodeHostID to RaftAddress mappings of known
// NodeHost instances.
message GossipConfig {
  // BindAddress is the address for the gossip service to bind to and listen on.
  // Both UDP and TCP ports are used by the gossip service. The local gossip
  // service should be able to receive gossip service related messages by
  // binding to and listening on this address. BindAddress is usually in the
  // format of IP:Port, Hostname:Port or DNS Name:Port.
  string  BindAddress = 1;
  // AdvertiseAddress is the address to advertise to other NodeHost instances
  // used for NAT traversal. Gossip services running on remote NodeHost
  // instances will use AdvertiseAddress to exchange gossip service related
  // messages. AdvertiseAddress is in the format of IP:Port.
  string  AdvertiseAddress = 2;
  // Seed is a list of AdvertiseAddress of remote NodeHost instances. Local
  // NodeHost instance will try to contact all of them to bootstrap the gossip
  // service. At least one reachable NodeHost instance is required to
  // successfully bootstrap the gossip service. Each seed address is in the
  // format of IP:Port, Hostname:Port or DNS Name:Port.
  //
  // It is ok to include seed addresses that are temporarily unreachable, e.g.
  // when launching the first NodeHost instance in your deployment, you can
  // include AdvertiseAddresses from other NodeHost instances that you plan to
  // launch shortly afterwards.
  repeated string  Seed = 3;
}

// NodeHostInfo provides info about the NodeHost, including its managed Raft
// cluster nodes and available Raft logs saved in its local persistent storage.
message NodeHostInfo {
  // NodeHostID is the unique identifier of the NodeHost instance.
  string NodeHostID = 1;
  // RaftAddress is the public address of the NodeHost used for exchanging Raft
  // messages, snapshots and other metadata with other NodeHost instances.
  string RaftAddress = 2;
  // Gossip contains gossip service related information.
  GossipInfo Gossip = 3;
  // ClusterInfo is a list of all Raft clusters managed by the NodeHost
  repeated ClusterInfo ClusterInfo = 4;
  // LogInfo is a list of raftio.NodeInfo values representing all Raft logs
  // stored on the NodeHost.
  repeated NodeInfo LogInfo = 5;
}


// ClusterInfo is a record for representing the state of a Raft cluster based
// on the knowledge of the local NodeHost instance.
message ClusterInfo {
  // ClusterID is the cluster ID of the Raft cluster node.
  uint64 ClusterID = 1;
  // NodeID is the node ID of the Raft cluster node.
  uint64 NodeID = 2;
  // Nodes is a map of member node IDs to their Raft addresses.
  map<uint64, string> Nodes = 3;
  // ConfigChangeIndex is the current config change index of the Raft node.
  // ConfigChangeIndex is Raft Log index of the last applied membership
  // change entry.
  uint64 ConfigChangeIndex = 4;
  // StateMachineType is the type of the state machine.
  uint64 StateMachineType = 5;
  // IsLeader indicates whether this is a leader node.
  bool IsLeader = 6;
  // IsObserver indicates whether this is a non-voting observer node.
  bool  IsObserver = 7;
  // IsWitness indicates whether this is a witness node without actual log.
  bool IsWitness = 8;
  // Pending is a boolean flag indicating whether details of the cluster node
  // is not available. The Pending flag is set to true usually because the node
  // has not had anything applied yet.
  bool  Pending = 9;
}

// GossipInfo contains details of the gossip service.
message GossipInfo {
  // Enabled is a boolean flag indicating whether the gossip service is enabled.
  bool Enabled = 1;
  // AdvertiseAddress is the advertise address used by the gossip service.
  string AdvertiseAddress = 2;
  // NumOfLiveNodeHosts is the number of current live NodeHost instances known
  // to the gossip service. Note that the gossip service always knowns the
  // local NodeHost instance itself. When the NumOfKnownNodeHosts value is 1,
  // it means the gossip service doesn't know any other NodeHost instance that
  // is considered as live.
  int32 NumOfKnownNodeHosts = 3;
}

// NodeInfo is used to identify a Raft node.
message NodeInfo {
  uint64 ClusterID = 1;
  uint64 NodeID = 2;
}

// NodeHostInfoOption is the option type used when querying NodeHostInfo.
message NodeHostInfoOption  {
  // SkipLogInfo is the boolean flag indicating whether Raft Log info should be
  // skipped when querying the NodeHostInfo.
  bool SkipLogInfo = 1;
}