// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.20.1
// source: pkg/server/server.proto

package server

import (
	database "github.com/mxplusb/pleiades/api/v1/database"
	raft "github.com/mxplusb/pleiades/api/v1/raft"
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ShardManagerClient is the client API for ShardManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ShardManagerClient interface {
	AddReplica(ctx context.Context, in *raft.AddReplicaRequest, opts ...grpc.CallOption) (*raft.AddReplicaReply, error)
	AddReplicaObserver(ctx context.Context, in *raft.AddReplicaObserverRequest, opts ...grpc.CallOption) (*raft.AddReplicaObserverReply, error)
	AddReplicaWitness(ctx context.Context, in *raft.AddReplicaWitnessRequest, opts ...grpc.CallOption) (*raft.AddReplicaWitnessReply, error)
	GetLeaderId(ctx context.Context, in *raft.GetLeaderIdRequest, opts ...grpc.CallOption) (*raft.GetLeaderIdReply, error)
	GetShardMembers(ctx context.Context, in *raft.GetShardMembersRequest, opts ...grpc.CallOption) (*raft.GetShardMembersReply, error)
	NewShard(ctx context.Context, in *raft.NewShardRequest, opts ...grpc.CallOption) (*raft.NewShardReply, error)
	RemoveData(ctx context.Context, in *raft.RemoveDataRequest, opts ...grpc.CallOption) (*raft.RemoveDataReply, error)
	RemoveReplica(ctx context.Context, in *raft.DeleteReplicaRequest, opts ...grpc.CallOption) (*raft.DeleteReplicaReply, error)
	StartReplica(ctx context.Context, in *raft.StartReplicaRequest, opts ...grpc.CallOption) (*raft.StartReplicaReply, error)
	StartReplicaObserver(ctx context.Context, in *raft.StartReplicaRequest, opts ...grpc.CallOption) (*raft.StartReplicaReply, error)
	StopReplica(ctx context.Context, in *raft.StopReplicaRequest, opts ...grpc.CallOption) (*raft.StopReplicaReply, error)
}

type shardManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewShardManagerClient(cc grpc.ClientConnInterface) ShardManagerClient {
	return &shardManagerClient{cc}
}

func (c *shardManagerClient) AddReplica(ctx context.Context, in *raft.AddReplicaRequest, opts ...grpc.CallOption) (*raft.AddReplicaReply, error) {
	out := new(raft.AddReplicaReply)
	err := c.cc.Invoke(ctx, "/server.ShardManager/AddReplica", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardManagerClient) AddReplicaObserver(ctx context.Context, in *raft.AddReplicaObserverRequest, opts ...grpc.CallOption) (*raft.AddReplicaObserverReply, error) {
	out := new(raft.AddReplicaObserverReply)
	err := c.cc.Invoke(ctx, "/server.ShardManager/AddReplicaObserver", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardManagerClient) AddReplicaWitness(ctx context.Context, in *raft.AddReplicaWitnessRequest, opts ...grpc.CallOption) (*raft.AddReplicaWitnessReply, error) {
	out := new(raft.AddReplicaWitnessReply)
	err := c.cc.Invoke(ctx, "/server.ShardManager/AddReplicaWitness", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardManagerClient) GetLeaderId(ctx context.Context, in *raft.GetLeaderIdRequest, opts ...grpc.CallOption) (*raft.GetLeaderIdReply, error) {
	out := new(raft.GetLeaderIdReply)
	err := c.cc.Invoke(ctx, "/server.ShardManager/GetLeaderId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardManagerClient) GetShardMembers(ctx context.Context, in *raft.GetShardMembersRequest, opts ...grpc.CallOption) (*raft.GetShardMembersReply, error) {
	out := new(raft.GetShardMembersReply)
	err := c.cc.Invoke(ctx, "/server.ShardManager/GetShardMembers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardManagerClient) NewShard(ctx context.Context, in *raft.NewShardRequest, opts ...grpc.CallOption) (*raft.NewShardReply, error) {
	out := new(raft.NewShardReply)
	err := c.cc.Invoke(ctx, "/server.ShardManager/NewShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardManagerClient) RemoveData(ctx context.Context, in *raft.RemoveDataRequest, opts ...grpc.CallOption) (*raft.RemoveDataReply, error) {
	out := new(raft.RemoveDataReply)
	err := c.cc.Invoke(ctx, "/server.ShardManager/RemoveData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardManagerClient) RemoveReplica(ctx context.Context, in *raft.DeleteReplicaRequest, opts ...grpc.CallOption) (*raft.DeleteReplicaReply, error) {
	out := new(raft.DeleteReplicaReply)
	err := c.cc.Invoke(ctx, "/server.ShardManager/RemoveReplica", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardManagerClient) StartReplica(ctx context.Context, in *raft.StartReplicaRequest, opts ...grpc.CallOption) (*raft.StartReplicaReply, error) {
	out := new(raft.StartReplicaReply)
	err := c.cc.Invoke(ctx, "/server.ShardManager/StartReplica", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardManagerClient) StartReplicaObserver(ctx context.Context, in *raft.StartReplicaRequest, opts ...grpc.CallOption) (*raft.StartReplicaReply, error) {
	out := new(raft.StartReplicaReply)
	err := c.cc.Invoke(ctx, "/server.ShardManager/StartReplicaObserver", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardManagerClient) StopReplica(ctx context.Context, in *raft.StopReplicaRequest, opts ...grpc.CallOption) (*raft.StopReplicaReply, error) {
	out := new(raft.StopReplicaReply)
	err := c.cc.Invoke(ctx, "/server.ShardManager/StopReplica", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ShardManagerServer is the server API for ShardManager service.
// All implementations must embed UnimplementedShardManagerServer
// for forward compatibility
type ShardManagerServer interface {
	AddReplica(context.Context, *raft.AddReplicaRequest) (*raft.AddReplicaReply, error)
	AddReplicaObserver(context.Context, *raft.AddReplicaObserverRequest) (*raft.AddReplicaObserverReply, error)
	AddReplicaWitness(context.Context, *raft.AddReplicaWitnessRequest) (*raft.AddReplicaWitnessReply, error)
	GetLeaderId(context.Context, *raft.GetLeaderIdRequest) (*raft.GetLeaderIdReply, error)
	GetShardMembers(context.Context, *raft.GetShardMembersRequest) (*raft.GetShardMembersReply, error)
	NewShard(context.Context, *raft.NewShardRequest) (*raft.NewShardReply, error)
	RemoveData(context.Context, *raft.RemoveDataRequest) (*raft.RemoveDataReply, error)
	RemoveReplica(context.Context, *raft.DeleteReplicaRequest) (*raft.DeleteReplicaReply, error)
	StartReplica(context.Context, *raft.StartReplicaRequest) (*raft.StartReplicaReply, error)
	StartReplicaObserver(context.Context, *raft.StartReplicaRequest) (*raft.StartReplicaReply, error)
	StopReplica(context.Context, *raft.StopReplicaRequest) (*raft.StopReplicaReply, error)
	mustEmbedUnimplementedShardManagerServer()
}

// UnimplementedShardManagerServer must be embedded to have forward compatible implementations.
type UnimplementedShardManagerServer struct {
}

func (UnimplementedShardManagerServer) AddReplica(context.Context, *raft.AddReplicaRequest) (*raft.AddReplicaReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddReplica not implemented")
}
func (UnimplementedShardManagerServer) AddReplicaObserver(context.Context, *raft.AddReplicaObserverRequest) (*raft.AddReplicaObserverReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddReplicaObserver not implemented")
}
func (UnimplementedShardManagerServer) AddReplicaWitness(context.Context, *raft.AddReplicaWitnessRequest) (*raft.AddReplicaWitnessReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddReplicaWitness not implemented")
}
func (UnimplementedShardManagerServer) GetLeaderId(context.Context, *raft.GetLeaderIdRequest) (*raft.GetLeaderIdReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLeaderId not implemented")
}
func (UnimplementedShardManagerServer) GetShardMembers(context.Context, *raft.GetShardMembersRequest) (*raft.GetShardMembersReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetShardMembers not implemented")
}
func (UnimplementedShardManagerServer) NewShard(context.Context, *raft.NewShardRequest) (*raft.NewShardReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewShard not implemented")
}
func (UnimplementedShardManagerServer) RemoveData(context.Context, *raft.RemoveDataRequest) (*raft.RemoveDataReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveData not implemented")
}
func (UnimplementedShardManagerServer) RemoveReplica(context.Context, *raft.DeleteReplicaRequest) (*raft.DeleteReplicaReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveReplica not implemented")
}
func (UnimplementedShardManagerServer) StartReplica(context.Context, *raft.StartReplicaRequest) (*raft.StartReplicaReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartReplica not implemented")
}
func (UnimplementedShardManagerServer) StartReplicaObserver(context.Context, *raft.StartReplicaRequest) (*raft.StartReplicaReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartReplicaObserver not implemented")
}
func (UnimplementedShardManagerServer) StopReplica(context.Context, *raft.StopReplicaRequest) (*raft.StopReplicaReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopReplica not implemented")
}
func (UnimplementedShardManagerServer) mustEmbedUnimplementedShardManagerServer() {}

// UnsafeShardManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ShardManagerServer will
// result in compilation errors.
type UnsafeShardManagerServer interface {
	mustEmbedUnimplementedShardManagerServer()
}

func RegisterShardManagerServer(s grpc.ServiceRegistrar, srv ShardManagerServer) {
	s.RegisterService(&ShardManager_ServiceDesc, srv)
}

func _ShardManager_AddReplica_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(raft.AddReplicaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardManagerServer).AddReplica(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.ShardManager/AddReplica",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardManagerServer).AddReplica(ctx, req.(*raft.AddReplicaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardManager_AddReplicaObserver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(raft.AddReplicaObserverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardManagerServer).AddReplicaObserver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.ShardManager/AddReplicaObserver",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardManagerServer).AddReplicaObserver(ctx, req.(*raft.AddReplicaObserverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardManager_AddReplicaWitness_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(raft.AddReplicaWitnessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardManagerServer).AddReplicaWitness(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.ShardManager/AddReplicaWitness",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardManagerServer).AddReplicaWitness(ctx, req.(*raft.AddReplicaWitnessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardManager_GetLeaderId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(raft.GetLeaderIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardManagerServer).GetLeaderId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.ShardManager/GetLeaderId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardManagerServer).GetLeaderId(ctx, req.(*raft.GetLeaderIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardManager_GetShardMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(raft.GetShardMembersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardManagerServer).GetShardMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.ShardManager/GetShardMembers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardManagerServer).GetShardMembers(ctx, req.(*raft.GetShardMembersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardManager_NewShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(raft.NewShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardManagerServer).NewShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.ShardManager/NewShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardManagerServer).NewShard(ctx, req.(*raft.NewShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardManager_RemoveData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(raft.RemoveDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardManagerServer).RemoveData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.ShardManager/RemoveData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardManagerServer).RemoveData(ctx, req.(*raft.RemoveDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardManager_RemoveReplica_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(raft.DeleteReplicaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardManagerServer).RemoveReplica(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.ShardManager/RemoveReplica",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardManagerServer).RemoveReplica(ctx, req.(*raft.DeleteReplicaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardManager_StartReplica_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(raft.StartReplicaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardManagerServer).StartReplica(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.ShardManager/StartReplica",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardManagerServer).StartReplica(ctx, req.(*raft.StartReplicaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardManager_StartReplicaObserver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(raft.StartReplicaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardManagerServer).StartReplicaObserver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.ShardManager/StartReplicaObserver",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardManagerServer).StartReplicaObserver(ctx, req.(*raft.StartReplicaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardManager_StopReplica_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(raft.StopReplicaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardManagerServer).StopReplica(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.ShardManager/StopReplica",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardManagerServer).StopReplica(ctx, req.(*raft.StopReplicaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ShardManager_ServiceDesc is the grpc.ServiceDesc for ShardManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ShardManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "server.ShardManager",
	HandlerType: (*ShardManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddReplica",
			Handler:    _ShardManager_AddReplica_Handler,
		},
		{
			MethodName: "AddReplicaObserver",
			Handler:    _ShardManager_AddReplicaObserver_Handler,
		},
		{
			MethodName: "AddReplicaWitness",
			Handler:    _ShardManager_AddReplicaWitness_Handler,
		},
		{
			MethodName: "GetLeaderId",
			Handler:    _ShardManager_GetLeaderId_Handler,
		},
		{
			MethodName: "GetShardMembers",
			Handler:    _ShardManager_GetShardMembers_Handler,
		},
		{
			MethodName: "NewShard",
			Handler:    _ShardManager_NewShard_Handler,
		},
		{
			MethodName: "RemoveData",
			Handler:    _ShardManager_RemoveData_Handler,
		},
		{
			MethodName: "RemoveReplica",
			Handler:    _ShardManager_RemoveReplica_Handler,
		},
		{
			MethodName: "StartReplica",
			Handler:    _ShardManager_StartReplica_Handler,
		},
		{
			MethodName: "StartReplicaObserver",
			Handler:    _ShardManager_StartReplicaObserver_Handler,
		},
		{
			MethodName: "StopReplica",
			Handler:    _ShardManager_StopReplica_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/server/server.proto",
}

// RaftHostClient is the client API for RaftHost service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RaftHostClient interface {
	Compact(ctx context.Context, in *raft.CompactRequest, opts ...grpc.CallOption) (*raft.CompactReply, error)
	GetHostConfig(ctx context.Context, in *raft.GetHostConfigRequest, opts ...grpc.CallOption) (*raft.GetHostConfigReply, error)
	//  rpc LeaderTransfer(raft.LeaderTransferRequest) returns (raft.LeaderTransferReply);
	Snapshot(ctx context.Context, in *raft.SnapshotRequest, opts ...grpc.CallOption) (*raft.SnapshotReply, error)
	Stop(ctx context.Context, in *raft.StopRequest, opts ...grpc.CallOption) (*raft.StopReply, error)
}

type raftHostClient struct {
	cc grpc.ClientConnInterface
}

func NewRaftHostClient(cc grpc.ClientConnInterface) RaftHostClient {
	return &raftHostClient{cc}
}

func (c *raftHostClient) Compact(ctx context.Context, in *raft.CompactRequest, opts ...grpc.CallOption) (*raft.CompactReply, error) {
	out := new(raft.CompactReply)
	err := c.cc.Invoke(ctx, "/server.RaftHost/Compact", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftHostClient) GetHostConfig(ctx context.Context, in *raft.GetHostConfigRequest, opts ...grpc.CallOption) (*raft.GetHostConfigReply, error) {
	out := new(raft.GetHostConfigReply)
	err := c.cc.Invoke(ctx, "/server.RaftHost/GetHostConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftHostClient) Snapshot(ctx context.Context, in *raft.SnapshotRequest, opts ...grpc.CallOption) (*raft.SnapshotReply, error) {
	out := new(raft.SnapshotReply)
	err := c.cc.Invoke(ctx, "/server.RaftHost/Snapshot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftHostClient) Stop(ctx context.Context, in *raft.StopRequest, opts ...grpc.CallOption) (*raft.StopReply, error) {
	out := new(raft.StopReply)
	err := c.cc.Invoke(ctx, "/server.RaftHost/Stop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RaftHostServer is the server API for RaftHost service.
// All implementations must embed UnimplementedRaftHostServer
// for forward compatibility
type RaftHostServer interface {
	Compact(context.Context, *raft.CompactRequest) (*raft.CompactReply, error)
	GetHostConfig(context.Context, *raft.GetHostConfigRequest) (*raft.GetHostConfigReply, error)
	//  rpc LeaderTransfer(raft.LeaderTransferRequest) returns (raft.LeaderTransferReply);
	Snapshot(context.Context, *raft.SnapshotRequest) (*raft.SnapshotReply, error)
	Stop(context.Context, *raft.StopRequest) (*raft.StopReply, error)
	mustEmbedUnimplementedRaftHostServer()
}

// UnimplementedRaftHostServer must be embedded to have forward compatible implementations.
type UnimplementedRaftHostServer struct {
}

func (UnimplementedRaftHostServer) Compact(context.Context, *raft.CompactRequest) (*raft.CompactReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Compact not implemented")
}
func (UnimplementedRaftHostServer) GetHostConfig(context.Context, *raft.GetHostConfigRequest) (*raft.GetHostConfigReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHostConfig not implemented")
}
func (UnimplementedRaftHostServer) Snapshot(context.Context, *raft.SnapshotRequest) (*raft.SnapshotReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Snapshot not implemented")
}
func (UnimplementedRaftHostServer) Stop(context.Context, *raft.StopRequest) (*raft.StopReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (UnimplementedRaftHostServer) mustEmbedUnimplementedRaftHostServer() {}

// UnsafeRaftHostServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RaftHostServer will
// result in compilation errors.
type UnsafeRaftHostServer interface {
	mustEmbedUnimplementedRaftHostServer()
}

func RegisterRaftHostServer(s grpc.ServiceRegistrar, srv RaftHostServer) {
	s.RegisterService(&RaftHost_ServiceDesc, srv)
}

func _RaftHost_Compact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(raft.CompactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftHostServer).Compact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.RaftHost/Compact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftHostServer).Compact(ctx, req.(*raft.CompactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftHost_GetHostConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(raft.GetHostConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftHostServer).GetHostConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.RaftHost/GetHostConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftHostServer).GetHostConfig(ctx, req.(*raft.GetHostConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftHost_Snapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(raft.SnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftHostServer).Snapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.RaftHost/Snapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftHostServer).Snapshot(ctx, req.(*raft.SnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftHost_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(raft.StopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftHostServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.RaftHost/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftHostServer).Stop(ctx, req.(*raft.StopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RaftHost_ServiceDesc is the grpc.ServiceDesc for RaftHost service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RaftHost_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "server.RaftHost",
	HandlerType: (*RaftHostServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Compact",
			Handler:    _RaftHost_Compact_Handler,
		},
		{
			MethodName: "GetHostConfig",
			Handler:    _RaftHost_GetHostConfig_Handler,
		},
		{
			MethodName: "Snapshot",
			Handler:    _RaftHost_Snapshot_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _RaftHost_Stop_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/server/server.proto",
}

// TransactionsClient is the client API for Transactions service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TransactionsClient interface {
	NewTransaction(ctx context.Context, in *database.NewTransactionRequest, opts ...grpc.CallOption) (*database.NewTransactionReply, error)
	CloseTransaction(ctx context.Context, in *database.CloseTransactionRequest, opts ...grpc.CallOption) (*database.CloseTransactionReply, error)
	Commit(ctx context.Context, in *database.CommitRequest, opts ...grpc.CallOption) (*database.CommitReply, error)
}

type transactionsClient struct {
	cc grpc.ClientConnInterface
}

func NewTransactionsClient(cc grpc.ClientConnInterface) TransactionsClient {
	return &transactionsClient{cc}
}

func (c *transactionsClient) NewTransaction(ctx context.Context, in *database.NewTransactionRequest, opts ...grpc.CallOption) (*database.NewTransactionReply, error) {
	out := new(database.NewTransactionReply)
	err := c.cc.Invoke(ctx, "/server.Transactions/NewTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionsClient) CloseTransaction(ctx context.Context, in *database.CloseTransactionRequest, opts ...grpc.CallOption) (*database.CloseTransactionReply, error) {
	out := new(database.CloseTransactionReply)
	err := c.cc.Invoke(ctx, "/server.Transactions/CloseTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionsClient) Commit(ctx context.Context, in *database.CommitRequest, opts ...grpc.CallOption) (*database.CommitReply, error) {
	out := new(database.CommitReply)
	err := c.cc.Invoke(ctx, "/server.Transactions/Commit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TransactionsServer is the server API for Transactions service.
// All implementations must embed UnimplementedTransactionsServer
// for forward compatibility
type TransactionsServer interface {
	NewTransaction(context.Context, *database.NewTransactionRequest) (*database.NewTransactionReply, error)
	CloseTransaction(context.Context, *database.CloseTransactionRequest) (*database.CloseTransactionReply, error)
	Commit(context.Context, *database.CommitRequest) (*database.CommitReply, error)
	mustEmbedUnimplementedTransactionsServer()
}

// UnimplementedTransactionsServer must be embedded to have forward compatible implementations.
type UnimplementedTransactionsServer struct {
}

func (UnimplementedTransactionsServer) NewTransaction(context.Context, *database.NewTransactionRequest) (*database.NewTransactionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewTransaction not implemented")
}
func (UnimplementedTransactionsServer) CloseTransaction(context.Context, *database.CloseTransactionRequest) (*database.CloseTransactionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseTransaction not implemented")
}
func (UnimplementedTransactionsServer) Commit(context.Context, *database.CommitRequest) (*database.CommitReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Commit not implemented")
}
func (UnimplementedTransactionsServer) mustEmbedUnimplementedTransactionsServer() {}

// UnsafeTransactionsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TransactionsServer will
// result in compilation errors.
type UnsafeTransactionsServer interface {
	mustEmbedUnimplementedTransactionsServer()
}

func RegisterTransactionsServer(s grpc.ServiceRegistrar, srv TransactionsServer) {
	s.RegisterService(&Transactions_ServiceDesc, srv)
}

func _Transactions_NewTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(database.NewTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionsServer).NewTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.Transactions/NewTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionsServer).NewTransaction(ctx, req.(*database.NewTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transactions_CloseTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(database.CloseTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionsServer).CloseTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.Transactions/CloseTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionsServer).CloseTransaction(ctx, req.(*database.CloseTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transactions_Commit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(database.CommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionsServer).Commit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.Transactions/Commit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionsServer).Commit(ctx, req.(*database.CommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Transactions_ServiceDesc is the grpc.ServiceDesc for Transactions service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Transactions_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "server.Transactions",
	HandlerType: (*TransactionsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NewTransaction",
			Handler:    _Transactions_NewTransaction_Handler,
		},
		{
			MethodName: "CloseTransaction",
			Handler:    _Transactions_CloseTransaction_Handler,
		},
		{
			MethodName: "Commit",
			Handler:    _Transactions_Commit_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/server/server.proto",
}

// KVStoreServiceClient is the client API for KVStoreService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KVStoreServiceClient interface {
	CreateAccount(ctx context.Context, in *database.CreateAccountRequest, opts ...grpc.CallOption) (*database.CreateAccountReply, error)
	GetAccountInfo(ctx context.Context, in *database.GetAccountDescriptorRequest, opts ...grpc.CallOption) (*database.GetAccountDescriptorReply, error)
	DeleteAccount(ctx context.Context, in *database.GetAccountDescriptorRequest, opts ...grpc.CallOption) (*database.GetAccountDescriptorReply, error)
	CreateBucket(ctx context.Context, in *database.CreateBucketRequest, opts ...grpc.CallOption) (*database.CreateBucketReply, error)
	DeleteBucket(ctx context.Context, in *database.DeleteBucketRequest, opts ...grpc.CallOption) (*database.DeleteBucketReply, error)
	Get(ctx context.Context, in *database.GetRequest, opts ...grpc.CallOption) (*database.GetResponse, error)
	Put(ctx context.Context, in *database.PutRequest, opts ...grpc.CallOption) (*database.PutReply, error)
	Delete(ctx context.Context, in *database.DeleteRequest, opts ...grpc.CallOption) (*database.DeleteResponse, error)
}

type kVStoreServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewKVStoreServiceClient(cc grpc.ClientConnInterface) KVStoreServiceClient {
	return &kVStoreServiceClient{cc}
}

func (c *kVStoreServiceClient) CreateAccount(ctx context.Context, in *database.CreateAccountRequest, opts ...grpc.CallOption) (*database.CreateAccountReply, error) {
	out := new(database.CreateAccountReply)
	err := c.cc.Invoke(ctx, "/server.KVStoreService/CreateAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVStoreServiceClient) GetAccountInfo(ctx context.Context, in *database.GetAccountDescriptorRequest, opts ...grpc.CallOption) (*database.GetAccountDescriptorReply, error) {
	out := new(database.GetAccountDescriptorReply)
	err := c.cc.Invoke(ctx, "/server.KVStoreService/GetAccountInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVStoreServiceClient) DeleteAccount(ctx context.Context, in *database.GetAccountDescriptorRequest, opts ...grpc.CallOption) (*database.GetAccountDescriptorReply, error) {
	out := new(database.GetAccountDescriptorReply)
	err := c.cc.Invoke(ctx, "/server.KVStoreService/DeleteAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVStoreServiceClient) CreateBucket(ctx context.Context, in *database.CreateBucketRequest, opts ...grpc.CallOption) (*database.CreateBucketReply, error) {
	out := new(database.CreateBucketReply)
	err := c.cc.Invoke(ctx, "/server.KVStoreService/CreateBucket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVStoreServiceClient) DeleteBucket(ctx context.Context, in *database.DeleteBucketRequest, opts ...grpc.CallOption) (*database.DeleteBucketReply, error) {
	out := new(database.DeleteBucketReply)
	err := c.cc.Invoke(ctx, "/server.KVStoreService/DeleteBucket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVStoreServiceClient) Get(ctx context.Context, in *database.GetRequest, opts ...grpc.CallOption) (*database.GetResponse, error) {
	out := new(database.GetResponse)
	err := c.cc.Invoke(ctx, "/server.KVStoreService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVStoreServiceClient) Put(ctx context.Context, in *database.PutRequest, opts ...grpc.CallOption) (*database.PutReply, error) {
	out := new(database.PutReply)
	err := c.cc.Invoke(ctx, "/server.KVStoreService/Put", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVStoreServiceClient) Delete(ctx context.Context, in *database.DeleteRequest, opts ...grpc.CallOption) (*database.DeleteResponse, error) {
	out := new(database.DeleteResponse)
	err := c.cc.Invoke(ctx, "/server.KVStoreService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KVStoreServiceServer is the server API for KVStoreService service.
// All implementations must embed UnimplementedKVStoreServiceServer
// for forward compatibility
type KVStoreServiceServer interface {
	CreateAccount(context.Context, *database.CreateAccountRequest) (*database.CreateAccountReply, error)
	GetAccountInfo(context.Context, *database.GetAccountDescriptorRequest) (*database.GetAccountDescriptorReply, error)
	DeleteAccount(context.Context, *database.GetAccountDescriptorRequest) (*database.GetAccountDescriptorReply, error)
	CreateBucket(context.Context, *database.CreateBucketRequest) (*database.CreateBucketReply, error)
	DeleteBucket(context.Context, *database.DeleteBucketRequest) (*database.DeleteBucketReply, error)
	Get(context.Context, *database.GetRequest) (*database.GetResponse, error)
	Put(context.Context, *database.PutRequest) (*database.PutReply, error)
	Delete(context.Context, *database.DeleteRequest) (*database.DeleteResponse, error)
	mustEmbedUnimplementedKVStoreServiceServer()
}

// UnimplementedKVStoreServiceServer must be embedded to have forward compatible implementations.
type UnimplementedKVStoreServiceServer struct {
}

func (UnimplementedKVStoreServiceServer) CreateAccount(context.Context, *database.CreateAccountRequest) (*database.CreateAccountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAccount not implemented")
}
func (UnimplementedKVStoreServiceServer) GetAccountInfo(context.Context, *database.GetAccountDescriptorRequest) (*database.GetAccountDescriptorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccountInfo not implemented")
}
func (UnimplementedKVStoreServiceServer) DeleteAccount(context.Context, *database.GetAccountDescriptorRequest) (*database.GetAccountDescriptorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAccount not implemented")
}
func (UnimplementedKVStoreServiceServer) CreateBucket(context.Context, *database.CreateBucketRequest) (*database.CreateBucketReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBucket not implemented")
}
func (UnimplementedKVStoreServiceServer) DeleteBucket(context.Context, *database.DeleteBucketRequest) (*database.DeleteBucketReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBucket not implemented")
}
func (UnimplementedKVStoreServiceServer) Get(context.Context, *database.GetRequest) (*database.GetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedKVStoreServiceServer) Put(context.Context, *database.PutRequest) (*database.PutReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Put not implemented")
}
func (UnimplementedKVStoreServiceServer) Delete(context.Context, *database.DeleteRequest) (*database.DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedKVStoreServiceServer) mustEmbedUnimplementedKVStoreServiceServer() {}

// UnsafeKVStoreServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KVStoreServiceServer will
// result in compilation errors.
type UnsafeKVStoreServiceServer interface {
	mustEmbedUnimplementedKVStoreServiceServer()
}

func RegisterKVStoreServiceServer(s grpc.ServiceRegistrar, srv KVStoreServiceServer) {
	s.RegisterService(&KVStoreService_ServiceDesc, srv)
}

func _KVStoreService_CreateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(database.CreateAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVStoreServiceServer).CreateAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.KVStoreService/CreateAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVStoreServiceServer).CreateAccount(ctx, req.(*database.CreateAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVStoreService_GetAccountInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(database.GetAccountDescriptorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVStoreServiceServer).GetAccountInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.KVStoreService/GetAccountInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVStoreServiceServer).GetAccountInfo(ctx, req.(*database.GetAccountDescriptorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVStoreService_DeleteAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(database.GetAccountDescriptorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVStoreServiceServer).DeleteAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.KVStoreService/DeleteAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVStoreServiceServer).DeleteAccount(ctx, req.(*database.GetAccountDescriptorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVStoreService_CreateBucket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(database.CreateBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVStoreServiceServer).CreateBucket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.KVStoreService/CreateBucket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVStoreServiceServer).CreateBucket(ctx, req.(*database.CreateBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVStoreService_DeleteBucket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(database.DeleteBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVStoreServiceServer).DeleteBucket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.KVStoreService/DeleteBucket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVStoreServiceServer).DeleteBucket(ctx, req.(*database.DeleteBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVStoreService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(database.GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVStoreServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.KVStoreService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVStoreServiceServer).Get(ctx, req.(*database.GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVStoreService_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(database.PutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVStoreServiceServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.KVStoreService/Put",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVStoreServiceServer).Put(ctx, req.(*database.PutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVStoreService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(database.DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVStoreServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/server.KVStoreService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVStoreServiceServer).Delete(ctx, req.(*database.DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// KVStoreService_ServiceDesc is the grpc.ServiceDesc for KVStoreService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KVStoreService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "server.KVStoreService",
	HandlerType: (*KVStoreServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAccount",
			Handler:    _KVStoreService_CreateAccount_Handler,
		},
		{
			MethodName: "GetAccountInfo",
			Handler:    _KVStoreService_GetAccountInfo_Handler,
		},
		{
			MethodName: "DeleteAccount",
			Handler:    _KVStoreService_DeleteAccount_Handler,
		},
		{
			MethodName: "CreateBucket",
			Handler:    _KVStoreService_CreateBucket_Handler,
		},
		{
			MethodName: "DeleteBucket",
			Handler:    _KVStoreService_DeleteBucket_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _KVStoreService_Get_Handler,
		},
		{
			MethodName: "Put",
			Handler:    _KVStoreService_Put_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _KVStoreService_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/server/server.proto",
}
